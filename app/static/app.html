<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Longevity Alchemist Workspace</title>
    <style>
      :root {
        --bg: #e8edf4;
        --panel: #fdfefe;
        --ink: #162235;
        --muted: #53657a;
        --accent: #0e7cc7;
        --accent2: #095d96;
        --ok: #1f845a;
        --warn: #ad5f00;
        --error: #c9372c;
        --border: #d2deea;
        --surface-1: #f6f9fc;
        --surface-2: #edf3f9;
      }
      * { box-sizing: border-box; }
      html { -webkit-text-size-adjust: 100%; }
      body {
        margin: 0;
        font-family: "Trebuchet MS", "Segoe UI", "Helvetica Neue", sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at 0% 0%, #f8fbff 0, transparent 30%),
          radial-gradient(circle at 100% 0%, #f1f7fe 0, transparent 30%),
          linear-gradient(180deg, #edf2f8 0%, var(--bg) 100%);
      }
      .shell {
        max-width: 1060px;
        margin: 0 auto;
        padding: 1.1rem 1rem 1.25rem;
      }
      .topbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        margin-bottom: .95rem;
        padding: .5rem .6rem;
        border: 1px solid rgba(207, 221, 234, .8);
        border-radius: 16px;
        background: rgba(250, 253, 255, .76);
        backdrop-filter: blur(6px);
        box-shadow: 0 12px 24px rgba(17, 37, 58, .06);
      }
      .title { margin: 0; font-size: clamp(1.2rem, 2vw, 2rem); letter-spacing: .01em; }
      .muted { margin: .2rem 0 0; color: var(--muted); font-size: .9rem; }
      button {
        border: none;
        border-radius: 11px;
        padding: .6rem .75rem;
        font-weight: 600;
        cursor: pointer;
        transition: transform .08s ease, box-shadow .12s ease, background .12s ease;
        min-height: 44px;
      }
      button:active { transform: translateY(1px); }
      .top-actions { display: flex; gap: .5rem; align-items: center; }
      .hamburger {
        position: relative;
        width: 2.5rem;
        height: 2.5rem;
        border: 1px solid var(--border);
        background: #f0f6fb;
        color: #234964;
        border-radius: 10px;
      }
      .hamburger .icon-bars {
        width: 16px;
        height: 12px;
        display: inline-block;
        background:
          linear-gradient(#234964, #234964) 0 0 / 16px 2px no-repeat,
          linear-gradient(#234964, #234964) 0 5px / 16px 2px no-repeat,
          linear-gradient(#234964, #234964) 0 10px / 16px 2px no-repeat;
      }
      .alert-dot {
        position: absolute;
        top: 3px;
        right: 3px;
        width: 9px;
        height: 9px;
        border-radius: 50%;
        background: #d92b2b;
        border: 1px solid #ffffff;
        display: none;
      }
      .alert-dot.show { display: block; }
      .logout { background: #f0f4f8; color: #27425b; border: 1px solid var(--border); }
      .overlay {
        position: fixed;
        inset: 0;
        background: rgba(9, 24, 37, .22);
        opacity: 0;
        pointer-events: none;
        transition: opacity .2s ease;
        z-index: 20;
      }
      .overlay.open {
        opacity: 1;
        pointer-events: auto;
      }
      .drawer {
        position: fixed;
        top: 0;
        right: -320px;
        width: min(320px, 85vw);
        height: 100vh;
        background: linear-gradient(180deg, #f8fcff, #edf4fa);
        border-left: 1px solid var(--border);
        box-shadow: -14px 0 28px rgba(13, 34, 52, .18);
        padding: .9rem;
        z-index: 30;
        transition: right .22s ease;
      }
      .drawer.open { right: 0; }
      .drawer-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: .7rem;
      }
      .drawer-title {
        margin: 0;
        font-size: .98rem;
        color: #244862;
      }
      .close-drawer {
        width: 2rem;
        height: 2rem;
        border: 1px solid var(--border);
        background: #f7fbff;
        color: #335a76;
      }
      .drawer-nav {
        display: grid;
        gap: .5rem;
      }
      .nav-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        border: 1px solid #c9dcec;
        background: #e8f2fb;
        color: #1f4b67;
        border-radius: 10px;
        padding: .6rem .7rem;
        min-height: 44px;
      }
      .nav-item.active {
        background: #d4e9f8;
        border-color: #9dc8e4;
      }
      .card {
        background: linear-gradient(180deg, var(--panel) 0%, #f9fcff 100%);
        border: 1px solid var(--border);
        border-radius: 18px;
        box-shadow: 0 14px 32px rgba(15, 42, 66, .09);
        padding: 1rem;
      }
      .view { display: none; }
      .view.active { display: block; }
      .section-title { margin: .1rem 0 .35rem; font-size: 1.07rem; }
      .field { display: grid; gap: .35rem; margin-bottom: .7rem; }
      label { font-size: .84rem; color: #3f5469; letter-spacing: .01em; }
      input, select, textarea {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: .6rem .65rem;
        font-size: 16px;
        background: #ffffff;
        min-height: 44px;
      }
      input:focus, select:focus, textarea:focus {
        outline: none;
        border-color: #8ab9de;
        box-shadow: 0 0 0 3px rgba(90, 159, 210, .18);
      }
      textarea { min-height: 115px; resize: vertical; }
      .row { display: flex; gap: .5rem; }
      .row > * { flex: 1; }
      .chat-toolbar {
        display: flex;
        gap: .5rem;
        align-items: flex-end;
        margin-bottom: .55rem;
      }
      .chat-toolbar .field { margin-bottom: 0; }
      .mode-wrap {
        position: relative;
        min-width: 220px;
      }
      .mode-button {
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border: 1px solid var(--border);
        background: #f4f8fc;
        color: #213f57;
        padding: .58rem .65rem;
      }
      .mode-button .caret {
        font-size: .72rem;
        opacity: .8;
      }
      .mode-panel {
        position: absolute;
        right: 0;
        top: calc(100% + 6px);
        z-index: 5;
        width: min(320px, 82vw);
        border: 1px solid var(--border);
        border-radius: 12px;
        background: #ffffff;
        box-shadow: 0 12px 24px rgba(21, 45, 66, .16);
        padding: .35rem;
      }
      .mode-panel[hidden] { display: none; }
      .mode-option {
        width: 100%;
        border: 1px solid transparent;
        border-radius: 10px;
        background: transparent;
        text-align: left;
        color: #1f364b;
        padding: .5rem .55rem;
        margin: .08rem 0;
      }
      .mode-option:hover {
        border-color: #c9dced;
        background: #f2f8fd;
      }
      .mode-option.active {
        border-color: #98c0de;
        background: #e8f3fc;
      }
      .mode-option .line1 {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 700;
      }
      .mode-option .line2 {
        color: var(--muted);
        font-size: .82rem;
        margin-top: .1rem;
      }
      .mode-check {
        color: #1f845a;
        font-size: .85rem;
      }
      .btn-primary { background: var(--accent); color: #fff; }
      .btn-primary:hover { background: var(--accent2); box-shadow: 0 8px 16px rgba(12, 93, 146, .2); }
      .btn-ghost { background: #f3f6fa; color: #24384f; border: 1px solid var(--border); }
      .btn-ghost:hover { background: #e9f0f7; }
      .chat-view { gap: .65rem; }
      .view.chat-view { display: none; }
      .view.active.chat-view { display: grid; }
      .chat-surface {
        border: 1px solid #d6e1ec;
        background: linear-gradient(180deg, var(--surface-1) 0%, var(--surface-2) 100%);
        border-radius: 14px;
        padding: .7rem;
      }
      .composer {
        display: flex;
        align-items: center;
        gap: .45rem;
        border: 1px solid #c5d7e8;
        border-radius: 999px;
        background: #ffffff;
        box-shadow: 0 7px 14px rgba(10, 30, 48, .09);
        padding: .35rem .4rem;
        margin: .1rem 0 .25rem;
      }
      .composer-btn {
        width: 2.1rem;
        height: 2.1rem;
        border-radius: 999px;
        border: 1px solid transparent;
        background: transparent;
        color: #2a4b67;
        font-size: 1.2rem;
        line-height: 1;
        padding: 0;
      }
      .composer-btn:hover { background: #eef5fb; border-color: #d4e3f0; }
      .composer-btn.voice {
        font-size: .72rem;
        font-weight: 700;
        border-color: #d8e6f3;
        background: #f3f8fd;
      }
      .composer-btn.voice.listening {
        background: #ffe8d7;
        border-color: #ffd0ad;
        color: #8d4c0d;
      }
      .composer-send {
        width: 2.1rem;
        height: 2.1rem;
        border-radius: 999px;
        background: #111111;
        color: #ffffff;
        font-size: .72rem;
        font-weight: 700;
        padding: 0;
      }
      .composer-send:hover { background: #000000; }
      .composer-input {
        flex: 1;
        border: none;
        outline: none;
        font-size: 16px;
        background: transparent;
        min-width: 0;
        min-height: 38px;
      }
      .composer-input::placeholder { color: #7a8b9b; }
      .composer-tools {
        display: inline-flex;
        align-items: center;
        gap: .25rem;
      }
      .composer-hint {
        color: var(--muted);
        font-size: .78rem;
        margin: .1rem 0 .25rem .2rem;
      }
      .chat-controls {
        display: flex;
        gap: .55rem;
        align-items: end;
        flex-wrap: wrap;
      }
      .chat-controls .field { margin-bottom: 0; min-width: 210px; }
      .chat-quick-actions {
        margin-left: auto;
        display: inline-flex;
        gap: .45rem;
      }
      .notice { min-height: 1.2rem; font-size: .86rem; margin-top: .25rem; color: var(--muted); }
      .notice.ok { color: var(--ok); }
      .notice.warn { color: var(--warn); }
      .notice.error { color: var(--error); }
      .status {
        display: inline-flex;
        align-items: center;
        gap: .4rem;
        font-size: .82rem;
        padding: .2rem .45rem;
        border-radius: 999px;
        border: 1px solid #bfd6e8;
        background: #ecf5fb;
        color: #275372;
      }
      .status.ok { border-color: #b8decb; background: #e9f8ef; color: #1f6848; }
      .status.warn { border-color: #e1d0b1; background: #fdf5e8; color: #8b5310; }
      .grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: .65rem; }
      .chat-answer {
        margin-top: .2rem;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: #f7fbff;
        padding: .78rem;
      }
      .chat-answer h1, .chat-answer h2, .chat-answer h3, .chat-answer h4 {
        margin: .55rem 0 .35rem;
      }
      .chat-answer p { margin: .45rem 0; line-height: 1.5; }
      .chat-answer ul { margin: .25rem 0 .5rem 1.1rem; }
      .chat-answer li { margin: .2rem 0; }
      .chat-log {
        border: 1px solid var(--border);
        border-radius: 10px;
        background: #f8fbff;
        min-height: 180px;
        max-height: 360px;
        overflow-y: auto;
        padding: .6rem;
      }
      .bubble {
        max-width: 85%;
        margin: .35rem 0;
        padding: .5rem .65rem;
        border-radius: 10px;
        line-height: 1.35;
        font-size: .9rem;
      }
      .bubble.coach {
        background: #e7f1fb;
        color: #204a66;
        border: 1px solid #c8deef;
      }
      .bubble.user {
        margin-left: auto;
        background: #dff3e8;
        color: #1f5f41;
        border: 1px solid #bde0cd;
      }
      .table {
        width: 100%;
        border-collapse: collapse;
        margin-top: .4rem;
      }
      .table-wrap {
        width: 100%;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }
      .table th, .table td {
        border-bottom: 1px solid #e7edf4;
        padding: .45rem;
        text-align: left;
        font-size: .86rem;
      }
      .hint { font-size: .84rem; color: var(--muted); margin-top: .3rem; }
      @media (max-width: 900px) {
        .grid-2 { grid-template-columns: 1fr; }
        .topbar { border-radius: 13px; }
      }
      @media (max-width: 680px) {
        .shell {
          max-width: 560px;
          min-height: 100vh;
          padding: .72rem .62rem calc(1rem + env(safe-area-inset-bottom));
        }
        .card {
          border-radius: 16px;
          padding: .72rem;
        }
        .topbar {
          align-items: flex-start;
          flex-wrap: wrap;
          gap: .65rem;
        }
        .top-actions {
          width: 100%;
          justify-content: flex-end;
        }
        .row {
          flex-wrap: wrap;
        }
        .row > * {
          min-width: 140px;
        }
        .drawer {
          width: min(360px, 92vw);
        }
        .chat-controls {
          flex-direction: column;
          align-items: stretch;
        }
        .chat-controls .field,
        .chat-quick-actions {
          width: 100%;
          margin-left: 0;
        }
        .chat-quick-actions {
          display: flex;
          gap: .45rem;
        }
        .composer {
          gap: .35rem;
          padding: .3rem .35rem;
        }
        .composer-btn,
        .composer-send {
          width: 2.2rem;
          height: 2.2rem;
        }
        .table th, .table td {
          white-space: nowrap;
        }
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <div class="topbar">
        <div>
          <h1 class="title">Longevity Workspace</h1>
          <p class="muted" id="welcome">Loading session...</p>
        </div>
        <div class="top-actions">
          <button class="hamburger" id="menu-toggle" aria-label="Open menu">
            <span class="icon-bars" aria-hidden="true"></span>
            <span class="alert-dot" id="intake-alert-dot" aria-hidden="true"></span>
          </button>
          <button class="logout" id="logout">Log Out</button>
        </div>
      </div>
      <div class="overlay" id="menu-overlay"></div>
      <aside class="drawer" id="menu-drawer">
        <div class="drawer-header">
          <h3 class="drawer-title">Workspace Menu</h3>
          <button class="close-drawer" id="menu-close" aria-label="Close menu">x</button>
        </div>
        <div class="drawer-nav">
          <button id="menu-chat" class="nav-item active"><span>Chat</span></button>
          <button id="menu-summary" class="nav-item"><span>Overall Summary</span></button>
          <button id="menu-intake" class="nav-item"><span>Intake</span><span id="intake-badge" class="status warn">pending</span></button>
          <button id="menu-settings" class="nav-item"><span>Settings</span></button>
          <button id="menu-usage" class="nav-item"><span>Model Usage</span></button>
          <button id="menu-feedback" class="nav-item"><span>Feedback</span></button>
        </div>
      </aside>

      <section class="card">
        <article id="view-chat" class="view active chat-view">
          <h2 class="section-title">Default Chat</h2>
          <p class="muted">Ask a coaching question anytime. Mode controls response depth: Quick is faster, Deep is more thorough.</p>
          <div class="chat-surface">
          <div class="field">
            <label for="chat-question">Question</label>
            <div class="composer">
              <input id="chat-image-file" type="file" accept="image/*" style="display:none;" />
              <button class="composer-btn" id="chat-image" type="button" aria-label="Attach image">+</button>
              <input id="chat-question" class="composer-input" type="text" placeholder="Ask anything" autocomplete="off" />
              <div class="composer-tools">
                <button class="composer-btn voice" id="chat-voice" type="button" aria-label="Voice input">Mic</button>
                <button class="composer-send" id="chat-send" type="button" aria-label="Send">Go</button>
              </div>
            </div>
            <div class="composer-hint">Enter to send. Shift+Enter for newline where supported.</div>
          </div>
          <div class="chat-controls">
            <div class="field">
              <label>Mode</label>
              <div class="mode-wrap">
                <button class="mode-button" id="chat-mode-button" aria-haspopup="true" aria-expanded="false" type="button">
                  <span id="chat-mode-label">Auto</span>
                  <span class="caret">v</span>
                </button>
                <div class="mode-panel" id="chat-mode-panel" hidden>
                  <button class="mode-option active" type="button" data-mode="auto">
                    <span class="line1">Auto <span class="mode-check">✓</span></span>
                    <span class="line2">Chooses Quick or Deep from question complexity.</span>
                  </button>
                  <button class="mode-option" type="button" data-mode="quick">
                    <span class="line1">Quick <span class="mode-check" hidden>✓</span></span>
                    <span class="line2">Faster response with concise analysis.</span>
                  </button>
                  <button class="mode-option" type="button" data-mode="deep">
                    <span class="line1">Deep <span class="mode-check" hidden>✓</span></span>
                    <span class="line2">Uses Deep Thinker for broader reasoning.</span>
                  </button>
                </div>
              </div>
            </div>
            <div class="chat-quick-actions">
              <button class="btn-ghost" id="chat-clear">Clear</button>
              <button class="btn-ghost" id="chat-daily-start">Daily Check-In</button>
            </div>
          </div>
          <div class="notice" id="chat-notice"></div>
          <div id="chat-answer" class="chat-answer" style="display:none;"></div>
          </div>
        </article>

        <article id="view-intake" class="view">
          <h2 class="section-title">Intake Coach</h2>
          <p class="muted">Complete intake through a guided coach chat. Answer naturally with your preferred units (lb/kg, in/cm, etc.).</p>
          <div class="notice" id="intake-status"></div>
          <div class="field">
            <label for="intake-top-goals">Top Goals (optional starter)</label>
            <input id="intake-top-goals" type="text" placeholder="energy, sleep, weight loss" />
          </div>
          <div class="row">
            <button class="btn-primary" id="intake-start">Start / Resume Intake Coach</button>
            <button class="btn-ghost" id="intake-refresh">Refresh Status</button>
          </div>
          <div class="field"><label>Coach Chat</label><div id="intake-chat-log" class="chat-log"></div></div>
          <div class="field">
            <label for="intake-answer">Your Answer</label>
            <textarea id="intake-answer" placeholder="Type answer for current intake question"></textarea>
          </div>
          <div class="row">
            <button class="btn-primary" id="intake-answer-send">Send Answer</button>
            <button class="btn-ghost" id="intake-complete" style="display:none;">Finalize Intake</button>
          </div>
          <div class="notice" id="intake-notice"></div>
        </article>

        <article id="view-summary" class="view">
          <h2 class="section-title">Overall Summary</h2>
          <p class="muted">Snapshot of today plus 7-day and 30-day trends from your daily logs.</p>
          <div class="row">
            <button class="btn-primary" id="summary-refresh">Refresh Summary</button>
          </div>
          <div class="chat-answer" id="summary-health" style="margin-top:.7rem;">No health score yet.</div>
          <div class="grid-2" style="margin-top:.6rem;">
            <div class="chat-answer" id="summary-today">No summary yet.</div>
            <div class="chat-answer" id="summary-trends">No summary yet.</div>
          </div>
          <div class="chat-answer" id="summary-insights" style="margin-top:.7rem;">No summary yet.</div>
          <div class="notice" id="summary-notice"></div>
        </article>

        <article id="view-settings" class="view">
          <h2 class="section-title">Settings</h2>
          <p class="muted">Update AI settings or change password from this menu at any time.</p>
          <p class="hint">Model pricing shown here uses provider list rates (OpenAI API Pricing and Gemini API Pricing), last synced on February 15, 2026.</p>
          <div class="grid-2">
            <div>
              <h3 class="section-title">AI Settings</h3>
              <div class="field"><label for="provider">Provider</label><select id="provider"><option value="">Select provider</option><option value="openai">OpenAI (ChatGPT)</option><option value="gemini">Gemini</option></select></div>
              <div class="field"><label for="api-key">API Key</label><input id="api-key" type="password" placeholder="Required for first-time setup" /><div class="hint" id="api-key-mask"></div></div>
              <div class="field"><label for="deep-model">Deep Thinker Model</label><select id="deep-model"><option value="">Select model</option></select></div>
              <div class="field"><label for="reason-model">Reasoning Model</label><select id="reason-model"><option value="">Select model</option></select></div>
              <div class="field"><label for="utility-model">Utility Model</label><select id="utility-model"><option value="">Select model</option></select></div>
              <div class="row"><button class="btn-primary" id="ai-save">Save AI Settings</button><button class="btn-ghost" id="ai-load">Load Current</button></div>
              <div class="notice" id="ai-notice"></div>
            </div>
            <div>
              <h3 class="section-title">Password</h3>
              <div class="field"><label for="current-password">Current Password</label><input id="current-password" type="password" /></div>
              <div class="field"><label for="new-password">New Password</label><input id="new-password" type="password" /></div>
              <button class="btn-primary" id="password-save">Change Password</button>
              <div class="notice" id="password-notice"></div>
              <h3 class="section-title" style="margin-top:1rem;">Data Reset</h3>
              <div class="row">
                <button class="btn-ghost" id="reset-user-data">Reinitialize User Data</button>
                <button class="btn-ghost" id="reset-model-usage">Reset Model Stats</button>
              </div>
              <div class="notice" id="reset-notice"></div>
            </div>
          </div>
        </article>

        <article id="view-usage" class="view">
          <h2 class="section-title">Model Token Usage</h2>
          <p class="muted">Token usage is tracked per user/provider/model for visibility and cost control.</p>
          <button class="btn-ghost" id="usage-refresh">Refresh</button>
          <div class="table-wrap">
            <table class="table" id="usage-table">
              <thead><tr><th>Provider</th><th>Model</th><th>Requests</th><th>Prompt</th><th>Completion</th><th>Total</th><th>Rough Cost (USD)</th></tr></thead>
              <tbody></tbody>
            </table>
          </div>
          <div class="hint" id="usage-hint"></div>
        </article>

        <article id="view-feedback" class="view">
          <h2 class="section-title">Feature Ideas And Bug Capture</h2>
          <p class="muted">Capture new feature ideas, bugs, and product suggestions. Entries are shared across users for centralized review.</p>
          <div class="grid-2">
            <div>
              <div class="field">
                <label for="feedback-category">Type</label>
                <select id="feedback-category">
                  <option value="feature">Feature</option>
                  <option value="idea">Idea</option>
                  <option value="bug">Bug</option>
                </select>
              </div>
              <div class="field">
                <label for="feedback-title">Title</label>
                <input id="feedback-title" type="text" placeholder="Short title" />
              </div>
              <div class="field">
                <label for="feedback-details">Details</label>
                <textarea id="feedback-details" placeholder="What happened or what should be added?"></textarea>
              </div>
              <div class="field">
                <label for="feedback-page">Where in app? (optional)</label>
                <input id="feedback-page" type="text" placeholder="chat, intake, settings..." />
              </div>
              <div class="row">
                <button class="btn-primary" id="feedback-submit">Submit Entry</button>
                <button class="btn-ghost" id="feedback-clear-form">Clear Form</button>
              </div>
            </div>
            <div>
              <h3 class="section-title">Data Actions</h3>
              <p class="muted">Export all captured entries to CSV or clear all entries from the shared list.</p>
              <div class="row">
                <button class="btn-ghost" id="feedback-export">Export CSV</button>
                <button class="btn-ghost" id="feedback-clear-all">Clear All Entries</button>
              </div>
            </div>
          </div>
          <div class="notice" id="feedback-notice"></div>
        </article>
      </section>
    </div>

    <script>
      const token = sessionStorage.getItem("access_token") || "";
      if (!token) window.location.href = "/onboarding";

      const el = (id) => document.getElementById(id);
      const views = ["chat", "summary", "intake", "settings", "usage", "feedback"];
      const intakeState = { sessionId: null, readyToComplete: false };
      const intakeChat = [];
      let speechRecognition = null;
      let voiceListening = false;
      let selectedChatImage = null;
      const dailyCheckin = {
        active: false,
        index: 0,
        logDate: null,
        payload: {},
        metricPayloads: [],
        extras: {},
        profile: { goalFocus: "general", primaryGoal: "", topGoals: [] },
        steps: []
      };
      const DAILY_CORE_STEPS = [
        { key: "sleep_hours", label: "Sleep Hours", question: "How many hours did you sleep last night?", type: "float", min: 0, max: 16 },
        { key: "energy", label: "Energy", question: "On a 1-10 scale, what is your energy today?", type: "int", min: 1, max: 10 },
        { key: "mood", label: "Mood", question: "On a 1-10 scale, what is your mood today?", type: "int", min: 1, max: 10 },
        { key: "stress", label: "Stress", question: "On a 1-10 scale, what is your stress today?", type: "int", min: 1, max: 10 },
        { key: "training_done", label: "Training Done", question: "Did you complete training today? (yes/no)", type: "bool" },
        { key: "nutrition_on_plan", label: "Nutrition On Plan", question: "Was your nutrition on plan today? (yes/no)", type: "bool" }
      ];
      const DAILY_OPTIONAL_SIGNAL_STEP = {
        key: "tracked_signals",
        label: "Optional Signals",
        question: "Which optional signals did you track today? (comma separated: weight, blood pressure, bed/wake times, last meal time, none)",
        type: "signals"
      };
      const DAILY_OPTIONAL_STEPS = {
        weight: { key: "weight_kg", label: "Weight", question: "What was your weight this morning? (kg or lbs)", type: "weight" },
        bp: { key: "bp", label: "Blood Pressure", question: "What was your blood pressure reading? (e.g., 120/80)", type: "bp" },
        sleep_timing: { key: "sleep_timing", label: "Sleep Timing", question: "What time did you go to bed and wake up? (e.g., 11:00pm, 6:30am)", type: "text" },
        last_meal: { key: "last_meal", label: "Last Meal Time", question: "What time was your last meal?", type: "text" }
      };
      const DAILY_NOTES_STEP = { key: "notes", label: "Notes", question: "Any short note for today? (type 'skip' to skip)", type: "text" };
      const CHAT_MODE_PRESETS = {
        auto: { label: "Auto", mode: "quick", deepThink: false },
        quick: { label: "Quick", mode: "quick", deepThink: false },
        deep: { label: "Deep", mode: "deep", deepThink: true }
      };
      let selectedChatMode = "auto";

      function authHeaders() {
        return { "Authorization": "Bearer " + token, "Content-Type": "application/json" };
      }

      function setNotice(id, text, kind) {
        const node = el(id);
        node.textContent = text || "";
        node.className = "notice" + (kind ? " " + kind : "");
      }

      function escapeHtml(value) {
        return String(value || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function renderSimpleMarkdown(markdownText) {
        const src = String(markdownText || "").replace(/\r\n/g, "\n");
        const lines = src.split("\n");
        let html = "";
        let inList = false;
        for (const rawLine of lines) {
          const line = rawLine.trimEnd();
          if (!line.trim()) {
            if (inList) {
              html += "</ul>";
              inList = false;
            }
            continue;
          }
          const hMatch = line.match(/^(#{1,4})\s+(.*)$/);
          if (hMatch) {
            if (inList) {
              html += "</ul>";
              inList = false;
            }
            const level = Math.min(4, hMatch[1].length);
            let content = escapeHtml(hMatch[2]);
            content = content.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
            html += "<h" + level + ">" + content + "</h" + level + ">";
            continue;
          }
          const liMatch = line.match(/^[-*]\s+(.*)$/);
          if (liMatch) {
            if (!inList) {
              html += "<ul>";
              inList = true;
            }
            let item = escapeHtml(liMatch[1]);
            item = item.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
            html += "<li>" + item + "</li>";
            continue;
          }
          if (inList) {
            html += "</ul>";
            inList = false;
          }
          let paragraph = escapeHtml(line);
          paragraph = paragraph.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
          paragraph = paragraph.replace(/`([^`]+?)`/g, "<code>$1</code>");
          html += "<p>" + paragraph + "</p>";
        }
        if (inList) html += "</ul>";
        return html || "<p>No answer content.</p>";
      }

      function addIntakeChatMessage(role, text) {
        if (!text) return;
        intakeChat.push({ role, text });
        const log = el("intake-chat-log");
        const bubble = document.createElement("div");
        bubble.className = "bubble " + role;
        bubble.textContent = text;
        log.appendChild(bubble);
        log.scrollTop = log.scrollHeight;
      }

      function showView(name) {
        views.forEach((v) => {
          el("view-" + v).classList.toggle("active", v === name);
          el("menu-" + v).classList.toggle("active", v === name);
        });
        closeDrawer();
      }

      function openDrawer() {
        el("menu-drawer").classList.add("open");
        el("menu-overlay").classList.add("open");
      }

      function closeDrawer() {
        el("menu-drawer").classList.remove("open");
        el("menu-overlay").classList.remove("open");
      }

      function toggleDrawer() {
        if (el("menu-drawer").classList.contains("open")) {
          closeDrawer();
        } else {
          openDrawer();
        }
      }

      function openModePanel() {
        el("chat-mode-panel").hidden = false;
        el("chat-mode-button").setAttribute("aria-expanded", "true");
      }

      function closeModePanel() {
        el("chat-mode-panel").hidden = true;
        el("chat-mode-button").setAttribute("aria-expanded", "false");
      }

      function toggleModePanel() {
        if (el("chat-mode-panel").hidden) openModePanel();
        else closeModePanel();
      }

      function applyModeSelection(modeKey) {
        selectedChatMode = CHAT_MODE_PRESETS[modeKey] ? modeKey : "auto";
        el("chat-mode-label").textContent = CHAT_MODE_PRESETS[selectedChatMode].label;
        document.querySelectorAll(".mode-option").forEach((node) => {
          const active = node.getAttribute("data-mode") === selectedChatMode;
          node.classList.toggle("active", active);
          const check = node.querySelector(".mode-check");
          if (check) check.hidden = !active;
        });
        closeModePanel();
      }

      function resolveChatMode(question) {
        if (selectedChatMode !== "auto") return CHAT_MODE_PRESETS[selectedChatMode];
        // Cost guardrail: default auto mode always runs quick path.
        return CHAT_MODE_PRESETS.quick;
      }

      function currentDailyStep() {
        return dailyCheckin.steps[dailyCheckin.index] || null;
      }

      function detectGoalFocus(primaryGoal, topGoals) {
        const blob = (String(primaryGoal || "") + " " + String((topGoals || []).join(" "))).toLowerCase();
        if (blob.includes("energy") || blob.includes("fatigue")) return "energy";
        if (blob.includes("weight") || blob.includes("fat") || blob.includes("metabolic")) return "weight";
        if (blob.includes("heart") || blob.includes("bp") || blob.includes("blood pressure") || blob.includes("cardio")) return "heart";
        if (blob.includes("mental") || blob.includes("clarity") || blob.includes("focus")) return "clarity";
        return "general";
      }

      function orderedCoreStepsByGoal(focus) {
        const byKey = Object.fromEntries(DAILY_CORE_STEPS.map((s) => [s.key, s]));
        if (focus === "energy" || focus === "clarity") {
          return [byKey.sleep_hours, byKey.stress, byKey.energy, byKey.mood, byKey.training_done, byKey.nutrition_on_plan];
        }
        if (focus === "weight") {
          return [byKey.nutrition_on_plan, byKey.training_done, byKey.sleep_hours, byKey.energy, byKey.stress, byKey.mood];
        }
        if (focus === "heart") {
          return [byKey.stress, byKey.sleep_hours, byKey.training_done, byKey.nutrition_on_plan, byKey.energy, byKey.mood];
        }
        return DAILY_CORE_STEPS.slice();
      }

      async function loadDailyCheckinProfile() {
        try {
          const res = await fetch("/intake/baseline", { headers: { "Authorization": "Bearer " + token } });
          if (!res.ok) return { goalFocus: "general", primaryGoal: "", topGoals: [] };
          const body = await res.json();
          const primaryGoal = String(body.primary_goal || "");
          const topGoals = Array.isArray(body.top_goals) ? body.top_goals : [];
          return {
            goalFocus: detectGoalFocus(primaryGoal, topGoals),
            primaryGoal,
            topGoals
          };
        } catch (_) {
          return { goalFocus: "general", primaryGoal: "", topGoals: [] };
        }
      }

      function renderDailyCheckinPrompt(extraMessage) {
        const out = el("chat-answer");
        out.style.display = "block";
        const step = currentDailyStep();
        const hint = "Coach adapts this check-in to your goals and the signals you track.";
        if (!step) {
          out.innerHTML = "<h3>Daily Check-In</h3><p>Preparing check-in...</p>";
          return;
        }
        out.innerHTML = "<h3>Daily Check-In Coach</h3>"
          + "<p><strong>Step " + (dailyCheckin.index + 1) + " of " + dailyCheckin.steps.length + ":</strong> " + escapeHtml(step.label) + "</p>"
          + "<p>" + escapeHtml(step.question) + "</p>"
          + "<p><em>" + escapeHtml(hint) + "</em></p>"
          + (extraMessage ? "<p>" + escapeHtml(extraMessage) + "</p>" : "");
      }

      function parseDailyCheckinValue(step, rawText) {
        const text = String(rawText || "").trim();
        if (!text) throw new Error("Please enter an answer.");
        if (step.type === "float" || step.type === "int") {
          const num = Number(text);
          if (!Number.isFinite(num)) throw new Error("Please enter a number.");
          if (num < step.min || num > step.max) {
            throw new Error("Value out of range for " + step.label + ".");
          }
          return step.type === "int" ? Math.round(num) : num;
        }
        if (step.type === "bool") {
          const normalized = text.toLowerCase();
          if (["y", "yes", "true", "1"].includes(normalized)) return true;
          if (["n", "no", "false", "0"].includes(normalized)) return false;
          throw new Error("Please answer yes or no.");
        }
        if (step.type === "weight") {
          const lower = text.toLowerCase();
          const num = Number((lower.match(/-?\d+(\.\d+)?/) || [])[0]);
          if (!Number.isFinite(num)) throw new Error("Please enter a valid weight.");
          const kg = (lower.includes("lb") || lower.includes("lbs") || lower.includes("pound")) ? (num * 0.45359237) : num;
          if (kg < 30 || kg > 350) throw new Error("Weight appears out of range.");
          return Math.round(kg * 100) / 100;
        }
        if (step.type === "bp") {
          const m = text.match(/(\d{2,3})\s*\/\s*(\d{2,3})/);
          if (!m) throw new Error("Please enter blood pressure like 120/80.");
          const s = Number(m[1]);
          const d = Number(m[2]);
          if (s < 70 || s > 240 || d < 40 || d > 150) throw new Error("Blood pressure appears out of range.");
          return { systolic: s, diastolic: d };
        }
        if (step.type === "signals") {
          const normalized = text.toLowerCase();
          if (normalized.includes("none")) return [];
          const selected = [];
          if (normalized.includes("weight")) selected.push("weight");
          if (normalized.includes("blood pressure") || normalized.includes("bp")) selected.push("bp");
          if (normalized.includes("bed") || normalized.includes("wake") || normalized.includes("sleep time")) selected.push("sleep_timing");
          if (normalized.includes("last meal") || normalized.includes("ate") || normalized.includes("meal time")) selected.push("last_meal");
          return selected;
        }
        if (step.type === "text") {
          if (text.toLowerCase() === "skip") return null;
          return text.slice(0, 1200);
        }
        return text;
      }

      async function startDailyCheckin() {
        const profile = await loadDailyCheckinProfile();
        dailyCheckin.active = true;
        dailyCheckin.index = 0;
        dailyCheckin.logDate = new Date().toISOString().slice(0, 10);
        dailyCheckin.payload = {};
        dailyCheckin.metricPayloads = [];
        dailyCheckin.extras = {};
        dailyCheckin.profile = profile;
        dailyCheckin.steps = [...orderedCoreStepsByGoal(profile.goalFocus), DAILY_OPTIONAL_SIGNAL_STEP, DAILY_NOTES_STEP];
        el("chat-question").value = "";
        el("chat-question").focus();
        const starter = profile.primaryGoal
          ? ("Daily check-in started for your goal: " + profile.primaryGoal + ".")
          : "Daily check-in started.";
        renderDailyCheckinPrompt("Answer in the chat box and press Send.");
        setNotice("chat-notice", starter, "ok");
      }

      async function submitDailyCheckin() {
        const res = await fetch("/daily-log/" + dailyCheckin.logDate, {
          method: "PUT",
          headers: authHeaders(),
          body: JSON.stringify(dailyCheckin.payload),
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("chat-notice", body.detail || "Could not save daily check-in.", "error");
          return;
        }
        for (const metric of dailyCheckin.metricPayloads) {
          await fetch("/metrics", {
            method: "POST",
            headers: authHeaders(),
            body: JSON.stringify(metric)
          });
        }
        dailyCheckin.active = false;
        const out = el("chat-answer");
        out.style.display = "block";
        out.innerHTML = "<h3>Daily Check-In Saved</h3>"
          + "<p>Your daily log for " + dailyCheckin.logDate + " is saved.</p>"
          + "<p><em>Now ask any coaching question, and I will use this new daily signal.</em></p>";
        setNotice("chat-notice", "Daily check-in complete.", "ok");
      }

      async function handleDailyCheckinTurn(userInput) {
        const step = currentDailyStep();
        if (!step) return;
        let parsed;
        try {
          parsed = parseDailyCheckinValue(step, userInput);
        } catch (err) {
          setNotice("chat-notice", err.message || "Invalid answer.", "error");
          renderDailyCheckinPrompt("Please try that step again.");
          return;
        }
        if (step.key === "tracked_signals") {
          const chosen = Array.isArray(parsed) ? parsed : [];
          const optionalSteps = chosen
            .map((key) => DAILY_OPTIONAL_STEPS[key])
            .filter(Boolean);
          const notesIndex = dailyCheckin.steps.findIndex((s) => s.key === "notes");
          const insertionIndex = notesIndex >= 0 ? notesIndex : dailyCheckin.steps.length;
          dailyCheckin.steps.splice(insertionIndex, 0, ...optionalSteps);
        } else if (step.key === "weight_kg") {
          dailyCheckin.metricPayloads.push({
            metric_type: "weight_kg",
            value: parsed
          });
          dailyCheckin.extras.weight_kg = parsed;
        } else if (step.key === "bp") {
          dailyCheckin.metricPayloads.push({ metric_type: "bp_systolic", value: parsed.systolic });
          dailyCheckin.metricPayloads.push({ metric_type: "bp_diastolic", value: parsed.diastolic });
          dailyCheckin.extras.bp = parsed.systolic + "/" + parsed.diastolic;
        } else if (step.key === "sleep_timing") {
          dailyCheckin.extras.sleep_timing = parsed;
        } else if (step.key === "last_meal") {
          dailyCheckin.extras.last_meal = parsed;
        } else {
          dailyCheckin.payload[step.key] = parsed;
        }
        dailyCheckin.index += 1;
        el("chat-question").value = "";
        if (dailyCheckin.index >= dailyCheckin.steps.length) {
          const extraBits = [];
          if (dailyCheckin.extras.weight_kg != null) extraBits.push("weight: " + dailyCheckin.extras.weight_kg + " kg");
          if (dailyCheckin.extras.bp) extraBits.push("bp: " + dailyCheckin.extras.bp);
          if (dailyCheckin.extras.sleep_timing) extraBits.push("sleep timing: " + dailyCheckin.extras.sleep_timing);
          if (dailyCheckin.extras.last_meal) extraBits.push("last meal: " + dailyCheckin.extras.last_meal);
          if (extraBits.length) {
            const currentNotes = dailyCheckin.payload.notes ? String(dailyCheckin.payload.notes) + " | " : "";
            dailyCheckin.payload.notes = (currentNotes + extraBits.join("; ")).slice(0, 1200);
          }
          await submitDailyCheckin();
          return;
        }
        renderDailyCheckinPrompt();
        setNotice("chat-notice", "Captured. Next check-in question loaded.", "");
      }

      async function loadSession() {
        const res = await fetch("/auth/session", { headers: { "Authorization": "Bearer " + token } });
        if (!res.ok) {
          sessionStorage.removeItem("access_token");
          window.location.href = "/onboarding";
          return;
        }
        const body = await res.json();
        el("welcome").textContent = "Signed in as " + body.email;
      }

      function modelLabel(entry) {
        if (!entry.cost_known) return entry.model + " (cost n/a)";
        return entry.model + " ($" + Number(entry.input_cost_per_1m_usd).toFixed(2) + "/$" + Number(entry.output_cost_per_1m_usd).toFixed(2) + " per 1M)";
      }

      function renderModels(selectId, options, selected) {
        const node = el(selectId);
        node.innerHTML = '<option value="">Select model</option>';
        options.forEach((entry) => {
          const opt = document.createElement("option");
          opt.value = entry.model;
          opt.textContent = modelLabel(entry);
          node.appendChild(opt);
        });
        if (selected) node.value = selected;
      }

      async function loadModelOptions() {
        const provider = el("provider").value;
        const apiKey = el("api-key").value.trim();
        if (!provider || !apiKey) return;
        setNotice("ai-notice", "Validating key and loading models...", "");
        const res = await fetch("/auth/model-options", {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify({ ai_provider: provider, ai_api_key: apiKey })
        });
        if (!res.ok) {
          setNotice("ai-notice", "Could not validate key/models.", "error");
          return;
        }
        const body = await res.json();
        if (body.source !== "provider_api") {
          setNotice("ai-notice", "Provider key validation failed.", "error");
          return;
        }
        const opts = Array.isArray(body.model_options) ? body.model_options : [];
        renderModels("deep-model", opts, body.default_deep_thinker_model);
        renderModels("reason-model", opts, body.default_reasoning_model);
        renderModels("utility-model", opts, body.default_utility_model);
        setNotice("ai-notice", "Model catalog loaded.", "ok");
      }

      async function loadAiConfig() {
        const res = await fetch("/auth/ai-config", { headers: { "Authorization": "Bearer " + token } });
        if (!res.ok) {
          el("api-key").placeholder = "Required for first-time setup";
          el("api-key-mask").textContent = "";
          setNotice("ai-notice", "AI config not set yet.", "warn");
          return;
        }
        const body = await res.json();
        el("provider").value = body.ai_provider || "";
        renderModels("deep-model", [], body.ai_deep_thinker_model);
        renderModels("reason-model", [], body.ai_reasoning_model);
        renderModels("utility-model", [], body.ai_utility_model);
        el("api-key").value = "";
        el("api-key").placeholder = "Leave blank to keep existing key";
        el("api-key-mask").textContent = body.api_key_masked
          ? ("Saved key: " + body.api_key_masked)
          : "";
        setNotice("ai-notice", "Loaded current AI config. Enter a new API key only if you want to replace it.", "warn");
      }

      async function saveAiConfig() {
        const payload = {
          ai_provider: el("provider").value,
          ai_deep_thinker_model: el("deep-model").value,
          ai_reasoning_model: el("reason-model").value,
          ai_utility_model: el("utility-model").value,
          ai_api_key: el("api-key").value.trim()
        };
        if (!payload.ai_provider || !payload.ai_deep_thinker_model || !payload.ai_reasoning_model || !payload.ai_utility_model) {
          setNotice("ai-notice", "Provider and all three model slots are required.", "error");
          return;
        }
        const res = await fetch("/auth/ai-config", {
          method: "PUT",
          headers: authHeaders(),
          body: JSON.stringify(payload)
        });
        if (!res.ok) {
          setNotice("ai-notice", "Could not save AI settings.", "error");
          return;
        }
        const body = await res.json().catch(() => ({}));
        el("api-key").value = "";
        if (body.api_key_masked) {
          el("api-key-mask").textContent = "Saved key: " + body.api_key_masked;
        }
        setNotice("ai-notice", "AI settings updated.", "ok");
      }

      async function loadIntakeStatus() {
        const res = await fetch("/intake/status", { headers: { "Authorization": "Bearer " + token } });
        if (!res.ok) {
          setNotice("intake-status", "Could not load intake status.", "error");
          return;
        }
        const body = await res.json();
        if (body.baseline_completed) {
          el("intake-badge").textContent = "completed";
          el("intake-badge").className = "status ok";
          el("intake-alert-dot").classList.remove("show");
          setNotice("intake-status", "Intake completed. You can update it anytime from this menu.", "ok");
        } else {
          el("intake-badge").textContent = "pending";
          el("intake-badge").className = "status warn";
          el("intake-alert-dot").classList.add("show");
          setNotice("intake-status", "Intake not completed yet. You can skip for now and run later from this menu.", "warn");
        }
      }

      function renderCoachState(payload) {
        intakeState.sessionId = payload.session_id;
        intakeState.readyToComplete = !!payload.ready_to_complete;
        const question = (payload.coach_message || "").trim();
        if (question) addIntakeChatMessage("coach", question);
        el("intake-complete").style.display = intakeState.readyToComplete ? "inline-block" : "none";
      }

      async function startIntakeConversation() {
        const topGoalsRaw = el("intake-top-goals").value.trim();
        const goals = topGoalsRaw
          ? topGoalsRaw.split(",").map((g) => g.trim()).filter((g) => g).slice(0, 3)
          : [];
        setNotice("intake-notice", "Starting intake coach...", "");
        const res = await fetch("/intake/conversation/start", {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify({ top_goals: goals.length ? goals : null })
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("intake-notice", body.detail || "Could not start intake coach.", "error");
          return;
        }
        el("intake-chat-log").innerHTML = "";
        intakeChat.length = 0;
        renderCoachState(await res.json());
        setNotice("intake-notice", "Coach started. Answer the current question.", "ok");
      }

      async function sendIntakeAnswer() {
        const answer = el("intake-answer").value.trim();
        if (!intakeState.sessionId) {
          setNotice("intake-notice", "Start intake coach first.", "warn");
          return;
        }
        if (!answer) {
          setNotice("intake-notice", "Enter an answer first.", "error");
          return;
        }
        addIntakeChatMessage("user", answer);
        setNotice("intake-notice", "Sending answer...", "");
        const res = await fetch("/intake/conversation/answer", {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify({ session_id: intakeState.sessionId, answer })
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("intake-notice", body.detail || "Could not submit answer.", "error");
          return;
        }
        el("intake-answer").value = "";
        renderCoachState(await res.json());
        setNotice("intake-notice", intakeState.readyToComplete ? "Ready to finalize intake." : "Answer recorded. Next question loaded.", "ok");
      }

      async function finalizeIntakeConversation() {
        if (!intakeState.sessionId) {
          setNotice("intake-notice", "Start intake coach first.", "warn");
          return;
        }
        setNotice("intake-notice", "Finalizing intake...", "");
        const res = await fetch("/intake/conversation/complete", {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify({ session_id: intakeState.sessionId })
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("intake-notice", body.detail || "Could not finalize intake.", "error");
          return;
        }
        intakeState.readyToComplete = false;
        el("intake-complete").style.display = "none";
        setNotice("intake-notice", "Intake complete. Redirecting to default chat.", "ok");
        await loadIntakeStatus();
        showView("chat");
      }

      async function sendChat() {
        const question = el("chat-question").value.trim();
        const hasImage = !!selectedChatImage;
        if (hasImage) {
          await sendImageChat(question);
          return;
        }
        if (!question) {
          setNotice("chat-notice", "Enter a question first.", "error");
          return;
        }
        if (dailyCheckin.active) {
          await handleDailyCheckinTurn(question);
          return;
        }
        const resolved = resolveChatMode(question);
        const stageMessages = [
          "Reviewing your goals and recent context...",
          "Running specialist coaching agents...",
          "Synthesizing a final coaching response..."
        ];
        let stageIdx = 0;
        setNotice("chat-notice", stageMessages[stageIdx], "");
        const noticeTimer = setInterval(() => {
          stageIdx = (stageIdx + 1) % stageMessages.length;
          setNotice("chat-notice", stageMessages[stageIdx], "");
        }, 1300);
        const res = await fetch("/coach/question", {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify({
            question,
            mode: resolved.mode,
            deep_think: resolved.deepThink
          })
        });
        clearInterval(noticeTimer);
        if (!res.ok) {
          setNotice("chat-notice", "Chat request failed.", "error");
          return;
        }
        const body = await res.json();
        el("chat-question").value = "";
        const out = el("chat-answer");
        out.style.display = "block";
        out.innerHTML = "<h3>Answer</h3>" + renderSimpleMarkdown(body.answer || "")
          + "<strong>Coach Follow-up Questions (Please answer next)</strong><ul>" + (body.suggested_questions || []).map((q) => "<li>" + q + "</li>").join("") + "</ul>"
          + "<p><em>Reply with your answers in your next message so guidance can be tailored and recorded.</em></p>";
        const flags = Array.isArray(body.safety_flags) ? body.safety_flags : [];
        const llmFailure = flags.some((f) => String(f).startsWith("llm_"));
        if (llmFailure) {
          if (flags.includes("llm_rate_limited")) {
            setNotice("chat-notice", "AI provider rate limit/quota reached. Returned practical fallback guidance.", "warn");
          } else if (flags.includes("llm_unavailable") || flags.includes("llm_provider_error")) {
            setNotice("chat-notice", "AI service timed out or is temporarily unavailable. Returned practical fallback guidance.", "warn");
          } else if (flags.includes("llm_auth_error") || flags.includes("llm_model_not_found")) {
            setNotice("chat-notice", "AI configuration issue detected. Check Settings and model selection.", "error");
          } else {
            setNotice("chat-notice", "AI provider/model error. Check Settings (provider, key, and model selections).", "error");
          }
        } else {
          setNotice("chat-notice", "Response ready (" + resolved.label + " mode).", "ok");
        }
      }

      async function sendImageChat(questionText) {
        if (dailyCheckin.active) {
          setNotice("chat-notice", "Finish current daily check-in before uploading an image.", "warn");
          return;
        }
        if (!selectedChatImage) {
          setNotice("chat-notice", "Select an image first.", "error");
          return;
        }
        const resolved = resolveChatMode(questionText || "image analysis");
        const form = new FormData();
        form.append("image", selectedChatImage);
        form.append("question", String(questionText || ""));
        form.append("mode", resolved.mode);
        form.append("deep_think", String(!!resolved.deepThink));
        setNotice("chat-notice", "Analyzing image with coach...", "");
        const res = await fetch("/coach/image", {
          method: "POST",
          headers: { "Authorization": "Bearer " + token },
          body: form,
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("chat-notice", body.detail || "Image request failed.", "error");
          return;
        }
        const body = await res.json();
        selectedChatImage = null;
        el("chat-image-file").value = "";
        el("chat-question").value = "";
        renderChatCoachResponse(body, resolved);
      }

      function renderChatCoachResponse(body, resolved) {
        const out = el("chat-answer");
        out.style.display = "block";
        out.innerHTML = "<h3>Answer</h3>" + renderSimpleMarkdown(body.answer || "")
          + "<strong>Coach Follow-up Questions (Please answer next)</strong><ul>" + (body.suggested_questions || []).map((q) => "<li>" + q + "</li>").join("") + "</ul>"
          + "<p><em>Reply with your answers in your next message so guidance can be tailored and recorded.</em></p>";
        const flags = Array.isArray(body.safety_flags) ? body.safety_flags : [];
        const llmFailure = flags.some((f) => String(f).startsWith("llm_"));
        if (llmFailure) {
          if (flags.includes("llm_rate_limited")) {
            setNotice("chat-notice", "AI provider rate limit/quota reached. Returned practical fallback guidance.", "warn");
          } else if (flags.includes("llm_unavailable") || flags.includes("llm_provider_error")) {
            setNotice("chat-notice", "AI service timed out or is temporarily unavailable. Returned practical fallback guidance.", "warn");
          } else if (flags.includes("llm_auth_error") || flags.includes("llm_model_not_found")) {
            setNotice("chat-notice", "AI configuration issue detected. Check Settings and model selection.", "error");
          } else {
            setNotice("chat-notice", "AI provider/model error. Check Settings (provider, key, and model selections).", "error");
          }
        } else {
          setNotice("chat-notice", "Response ready (" + resolved.label + " mode).", "ok");
        }
      }

      async function sendVoiceTranscript(transcript) {
        const text = String(transcript || "").trim();
        if (!text) {
          setNotice("chat-notice", "No transcript captured. Try again.", "error");
          return;
        }
        const resolved = resolveChatMode(text);
        setNotice("chat-notice", "Sending voice transcript...", "");
        const res = await fetch("/coach/voice", {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify({
            transcript: text,
            mode: resolved.mode,
            deep_think: resolved.deepThink
          })
        });
        if (!res.ok) {
          setNotice("chat-notice", "Voice request failed.", "error");
          return;
        }
        const body = await res.json();
        el("chat-question").value = "";
        renderChatCoachResponse(body, resolved);
      }

      function startVoiceInput() {
        if (dailyCheckin.active) {
          setNotice("chat-notice", "Finish current daily check-in before using voice.", "warn");
          return;
        }
        if (voiceListening) return;
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          setNotice("chat-notice", "Voice input is not supported in this browser.", "warn");
          return;
        }
        speechRecognition = new SpeechRecognition();
        speechRecognition.lang = "en-US";
        speechRecognition.interimResults = false;
        speechRecognition.maxAlternatives = 1;
        voiceListening = true;
        el("chat-voice").classList.add("listening");
        setNotice("chat-notice", "Listening... speak your question.", "");
        speechRecognition.onresult = async (event) => {
          const transcript = (((event || {}).results || [])[0] || [])[0]?.transcript || "";
          el("chat-question").value = transcript;
          await sendVoiceTranscript(transcript);
        };
        speechRecognition.onerror = () => {
          setNotice("chat-notice", "Voice input failed. Try again.", "error");
        };
        speechRecognition.onend = () => {
          voiceListening = false;
          el("chat-voice").classList.remove("listening");
        };
        speechRecognition.start();
      }

      function openImagePicker() {
        el("chat-image-file").click();
      }

      function onImageSelected(event) {
        const file = (((event || {}).target || {}).files || [])[0] || null;
        selectedChatImage = file;
        if (!file) {
          setNotice("chat-notice", "No image selected.", "warn");
          return;
        }
        setNotice("chat-notice", "Image selected: " + file.name + ". Ready to send.", "ok");
      }

      async function changePassword() {
        const payload = {
          current_password: el("current-password").value,
          new_password: el("new-password").value
        };
        if (!payload.current_password || !payload.new_password) {
          setNotice("password-notice", "Current and new password are required.", "error");
          return;
        }
        const res = await fetch("/auth/change-password", {
          method: "PUT",
          headers: authHeaders(),
          body: JSON.stringify(payload)
        });
        if (res.status === 204) {
          el("current-password").value = "";
          el("new-password").value = "";
          setNotice("password-notice", "Password updated.", "ok");
          return;
        }
        const body = await res.json().catch(() => ({}));
        setNotice("password-notice", body.detail || "Password update failed.", "error");
      }

      async function resetModelUsage() {
        const ok = window.confirm("Reset model usage stats for this account only?");
        if (!ok) return;
        setNotice("reset-notice", "Resetting model stats...", "");
        const res = await fetch("/auth/model-usage", {
          method: "DELETE",
          headers: { "Authorization": "Bearer " + token }
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("reset-notice", body.detail || "Could not reset model stats.", "error");
          return;
        }
        const body = await res.json().catch(() => ({}));
        setNotice("reset-notice", "Model stats reset. Rows removed: " + (body.deleted_rows ?? 0) + ".", "ok");
        await loadUsage();
      }

      async function resetUserData() {
        const ok = window.confirm(
          "Reinitialize user data (baseline, intake sessions, metrics, scores, daily logs, and chat summaries)? This cannot be undone."
        );
        if (!ok) return;
        setNotice("reset-notice", "Reinitializing user data...", "");
        const res = await fetch("/auth/data", {
          method: "DELETE",
          headers: { "Authorization": "Bearer " + token }
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("reset-notice", body.detail || "Could not reinitialize user data.", "error");
          return;
        }
        const body = await res.json().catch(() => ({}));
        setNotice("reset-notice", "User data reinitialized. Rows removed: " + (body.deleted_rows ?? 0) + ".", "ok");
        await loadIntakeStatus();
        showView("chat");
      }

      async function submitFeedback() {
        const payload = {
          category: el("feedback-category").value,
          title: el("feedback-title").value.trim(),
          details: el("feedback-details").value.trim(),
          page: el("feedback-page").value.trim() || null,
        };
        if (!payload.title || !payload.details) {
          setNotice("feedback-notice", "Title and details are required.", "error");
          return;
        }
        setNotice("feedback-notice", "Saving entry...", "");
        const res = await fetch("/feedback/entries", {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("feedback-notice", body.detail || "Could not save entry.", "error");
          return;
        }
        const body = await res.json().catch(() => ({}));
        setNotice("feedback-notice", "Saved entry #" + (body.id ?? "?") + ".", "ok");
        el("feedback-title").value = "";
        el("feedback-details").value = "";
        el("feedback-page").value = "";
      }

      async function exportFeedbackCsv() {
        setNotice("feedback-notice", "Preparing CSV...", "");
        const res = await fetch("/feedback/entries/export", {
          headers: { "Authorization": "Bearer " + token },
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("feedback-notice", body.detail || "Could not export CSV.", "error");
          return;
        }
        const blob = await res.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "feedback_entries.csv";
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(url);
        setNotice("feedback-notice", "CSV downloaded.", "ok");
      }

      async function clearAllFeedback() {
        const ok = window.confirm("Clear all feedback entries for all users?");
        if (!ok) return;
        setNotice("feedback-notice", "Clearing shared entries...", "");
        const res = await fetch("/feedback/entries", {
          method: "DELETE",
          headers: { "Authorization": "Bearer " + token },
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("feedback-notice", body.detail || "Could not clear entries.", "error");
          return;
        }
        const body = await res.json().catch(() => ({}));
        setNotice("feedback-notice", "Cleared entries: " + (body.deleted_rows ?? 0) + ".", "ok");
      }

      async function loadUsage() {
        const res = await fetch("/auth/model-usage", { headers: { "Authorization": "Bearer " + token } });
        if (!res.ok) {
          el("usage-hint").textContent = "Could not load usage.";
          return;
        }
        const body = await res.json();
        const tbody = el("usage-table").querySelector("tbody");
        tbody.innerHTML = "";
        const items = body.items || [];
        if (!items.length) {
          el("usage-hint").textContent = "No model usage yet. Ask a chat question to generate usage.";
          return;
        }
        items.forEach((item) => {
          const tr = document.createElement("tr");
          let roughCost = "n/a";
          if (typeof item.rough_cost_usd === "number" && Number.isFinite(item.rough_cost_usd)) {
            roughCost = "$" + Number(item.rough_cost_usd).toFixed(4);
          }
          tr.innerHTML = "<td>" + item.provider + "</td><td>" + item.model + "</td><td>" + item.request_count + "</td><td>" + item.prompt_tokens + "</td><td>" + item.completion_tokens + "</td><td>" + item.total_tokens + "</td><td>" + roughCost + "</td>";
          tbody.appendChild(tr);
        });
        el("usage-hint").textContent = "Rows are aggregated by provider/model for your account. Rough cost is estimated from known per-1M token pricing.";
      }

      function renderWindowSummary(window) {
        if (!window || !window.entries) return "<p>No entries in this window yet.</p>";
        return "<ul>"
          + "<li><strong>Entries:</strong> " + window.entries + "</li>"
          + "<li><strong>Avg Sleep:</strong> " + (window.avg_sleep_hours ?? "n/a") + "</li>"
          + "<li><strong>Avg Energy:</strong> " + (window.avg_energy ?? "n/a") + "</li>"
          + "<li><strong>Avg Mood:</strong> " + (window.avg_mood ?? "n/a") + "</li>"
          + "<li><strong>Avg Stress:</strong> " + (window.avg_stress ?? "n/a") + "</li>"
          + "<li><strong>Training Adherence:</strong> " + (window.training_adherence_pct ?? "n/a") + "%</li>"
          + "<li><strong>Nutrition Adherence:</strong> " + (window.nutrition_adherence_pct ?? "n/a") + "%</li>"
          + "</ul>";
      }

      async function loadOverallSummary() {
        setNotice("summary-notice", "Loading summary...", "");
        const res = await fetch("/summary/overall", { headers: { "Authorization": "Bearer " + token } });
        if (!res.ok) {
          setNotice("summary-notice", "Could not load summary.", "error");
          return;
        }
        const body = await res.json();
        const today = body.today || {};
        const categoryScores = body.category_scores || {};
        const wellnessReport = Array.isArray(body.wellness_report) ? body.wellness_report : [];
        const weeklyInsights = Array.isArray(body.weekly_personalized_insights) ? body.weekly_personalized_insights : [];
        const journey = body.personalized_journey || {};
        const journeySignals = Array.isArray(journey.pattern_signals) ? journey.pattern_signals : [];
        const journeyMeasures = Array.isArray(journey.prevention_measures) ? journey.prevention_measures : [];
        el("summary-health").innerHTML = "<h3>Health Score</h3><p><strong>" + (body.health_score ?? "n/a") + "/100</strong></p>"
          + "<p>Reflects Body Composition, Nutrition, Movement, Sleep, and Stress.</p>"
          + "<h4>Category Scores</h4><ul>"
          + Object.keys(categoryScores).map((k) => "<li><strong>" + escapeHtml(k) + ":</strong> " + categoryScores[k] + "/100</li>").join("")
          + "</ul>";
        el("summary-today").innerHTML = "<h3>Today</h3><ul>"
          + "<li><strong>Date:</strong> " + (today.log_date || "n/a") + "</li>"
          + "<li><strong>Sleep:</strong> " + (today.sleep_hours ?? "n/a") + "</li>"
          + "<li><strong>Energy:</strong> " + (today.energy ?? "n/a") + "</li>"
          + "<li><strong>Mood:</strong> " + (today.mood ?? "n/a") + "</li>"
          + "<li><strong>Stress:</strong> " + (today.stress ?? "n/a") + "</li>"
          + "<li><strong>Training:</strong> " + (today.training_done ? "yes" : "no") + "</li>"
          + "<li><strong>Nutrition:</strong> " + (today.nutrition_on_plan ? "yes" : "no") + "</li>"
          + "</ul>";
        el("summary-trends").innerHTML = "<h3>7-Day Trend</h3>" + renderWindowSummary(body.trend_7d)
          + "<h3>30-Day Trend</h3>" + renderWindowSummary(body.trend_30d);
        el("summary-insights").innerHTML = "<h3>Wellness Report</h3><ul>"
          + wellnessReport.map((row) => "<li><strong>" + escapeHtml(row.domain || "") + ":</strong> " + escapeHtml(String(row.status || "")) + " (" + (row.score ?? "n/a") + "/100)</li>").join("")
          + "</ul><h3>Weekly Personalized Insights</h3><ul>"
          + weeklyInsights.map((v) => "<li>" + escapeHtml(v) + "</li>").join("")
          + "</ul><h3>Personalized Journey</h3><p>" + escapeHtml(String(journey.narrative || "")) + "</p><h4>Detected Patterns</h4><ul>"
          + journeySignals.map((s) => "<li><strong>" + escapeHtml(String(s.pattern || "")) + ":</strong> " + escapeHtml(String(s.evidence || "")) + " -> " + escapeHtml(String(s.prevention_focus || "")) + "</li>").join("")
          + "</ul><h4>Prevention Measures</h4><ul>"
          + journeyMeasures.map((m) => "<li>" + escapeHtml(String(m || "")) + "</li>").join("")
          + "</ul><h3>Top Wins</h3><ul>"
          + (body.top_wins || []).map((v) => "<li>" + escapeHtml(v) + "</li>").join("")
          + "</ul><h3>Top Risks</h3><ul>"
          + (body.top_risks || []).map((v) => "<li>" + escapeHtml(v) + "</li>").join("")
          + "</ul><h3>Next Best Action</h3><p>" + escapeHtml(body.next_best_action || "n/a") + "</p>";
        setNotice("summary-notice", "Summary updated.", "ok");
      }

      el("menu-chat").addEventListener("click", () => showView("chat"));
      el("menu-summary").addEventListener("click", async () => { showView("summary"); await loadOverallSummary(); });
      el("menu-intake").addEventListener("click", () => showView("intake"));
      el("menu-settings").addEventListener("click", () => showView("settings"));
      el("menu-usage").addEventListener("click", async () => { showView("usage"); await loadUsage(); });
      el("menu-feedback").addEventListener("click", () => showView("feedback"));
      el("logout").addEventListener("click", () => { sessionStorage.removeItem("access_token"); window.location.href = "/onboarding"; });
      el("chat-send").addEventListener("click", sendChat);
      el("chat-voice").addEventListener("click", startVoiceInput);
      el("chat-image").addEventListener("click", openImagePicker);
      el("chat-image-file").addEventListener("change", onImageSelected);
      el("chat-clear").addEventListener("click", () => {
        el("chat-question").value = "";
        selectedChatImage = null;
        el("chat-image-file").value = "";
        setNotice("chat-notice", "", "");
      });
      el("chat-daily-start").addEventListener("click", async () => { await startDailyCheckin(); });
      el("chat-mode-button").addEventListener("click", (event) => {
        event.preventDefault();
        toggleModePanel();
      });
      document.querySelectorAll(".mode-option").forEach((node) => {
        node.addEventListener("click", () => applyModeSelection(node.getAttribute("data-mode") || "auto"));
      });
      document.addEventListener("click", (event) => {
        const wrap = document.querySelector(".mode-wrap");
        if (!wrap || wrap.contains(event.target)) return;
        closeModePanel();
      });
      el("intake-start").addEventListener("click", startIntakeConversation);
      el("intake-answer-send").addEventListener("click", sendIntakeAnswer);
      el("intake-complete").addEventListener("click", finalizeIntakeConversation);
      el("intake-refresh").addEventListener("click", loadIntakeStatus);
      el("ai-load").addEventListener("click", loadAiConfig);
      el("provider").addEventListener("change", loadModelOptions);
      el("api-key").addEventListener("input", () => { if (el("api-key").value.trim().length > 7) loadModelOptions(); });
      el("ai-save").addEventListener("click", saveAiConfig);
      el("password-save").addEventListener("click", changePassword);
      el("reset-user-data").addEventListener("click", resetUserData);
      el("reset-model-usage").addEventListener("click", resetModelUsage);
      el("usage-refresh").addEventListener("click", loadUsage);
      el("summary-refresh").addEventListener("click", loadOverallSummary);
      el("feedback-submit").addEventListener("click", submitFeedback);
      el("feedback-export").addEventListener("click", exportFeedbackCsv);
      el("feedback-clear-all").addEventListener("click", clearAllFeedback);
      el("feedback-clear-form").addEventListener("click", () => {
        el("feedback-title").value = "";
        el("feedback-details").value = "";
        el("feedback-page").value = "";
        setNotice("feedback-notice", "", "");
      });
      el("menu-toggle").addEventListener("click", toggleDrawer);
      el("menu-close").addEventListener("click", closeDrawer);
      el("menu-overlay").addEventListener("click", closeDrawer);

      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          closeModePanel();
          closeDrawer();
          return;
        }
        if (event.key !== "Enter") return;
        const target = event.target;
        if (target && target.tagName === "TEXTAREA") {
          if (event.shiftKey) return;
          event.preventDefault();
          if (el("view-chat").classList.contains("active")) sendChat();
          if (el("view-intake").classList.contains("active")) sendIntakeAnswer();
          return;
        }
        if (target && target.id === "chat-question") {
          if (event.shiftKey) return;
          event.preventDefault();
          sendChat();
        }
      });

      async function init() {
        applyModeSelection("auto");
        await loadSession();
        await loadIntakeStatus();
        await loadAiConfig();
        if ((window.location.hash || "").toLowerCase() === "#intake") {
          showView("intake");
        }
      }
      init();
    </script>
  </body>
</html>



