<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Longevity Alchemist Workspace</title>
    <style>
      :root {
        --bg: #e8edf4;
        --panel: #fdfefe;
        --ink: #162235;
        --muted: #53657a;
        --accent: #0e7cc7;
        --accent2: #095d96;
        --ok: #1f845a;
        --warn: #ad5f00;
        --error: #c9372c;
        --border: #d2deea;
        --surface-1: #f6f9fc;
        --surface-2: #edf3f9;
      }
      * { box-sizing: border-box; }
      html { -webkit-text-size-adjust: 100%; }
      body {
        margin: 0;
        font-family: "Trebuchet MS", "Segoe UI", "Helvetica Neue", sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at 0% 0%, #f8fbff 0, transparent 30%),
          radial-gradient(circle at 100% 0%, #f1f7fe 0, transparent 30%),
          linear-gradient(180deg, #edf2f8 0%, var(--bg) 100%);
      }
      .shell {
        max-width: 1060px;
        margin: 0 auto;
        padding: 1.1rem 1rem 1.25rem;
      }
      .topbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        margin-bottom: .95rem;
        padding: .5rem .6rem;
        border: 1px solid rgba(207, 221, 234, .8);
        border-radius: 16px;
        background: rgba(250, 253, 255, .76);
        backdrop-filter: blur(6px);
        box-shadow: 0 12px 24px rgba(17, 37, 58, .06);
      }
      .title { margin: 0; font-size: clamp(1.2rem, 2vw, 2rem); letter-spacing: .01em; }
      .muted { margin: .2rem 0 0; color: var(--muted); font-size: .9rem; }
      button {
        border: none;
        border-radius: 11px;
        padding: .6rem .75rem;
        font-weight: 600;
        cursor: pointer;
        transition: transform .08s ease, box-shadow .12s ease, background .12s ease;
        min-height: 44px;
      }
      button:active { transform: translateY(1px); }
      .top-actions { display: flex; gap: .5rem; align-items: center; }
      .hamburger {
        position: relative;
        width: 2.5rem;
        height: 2.5rem;
        border: 1px solid var(--border);
        background: #f0f6fb;
        color: #234964;
        border-radius: 10px;
      }
      .hamburger .icon-bars {
        width: 16px;
        height: 12px;
        display: inline-block;
        background:
          linear-gradient(#234964, #234964) 0 0 / 16px 2px no-repeat,
          linear-gradient(#234964, #234964) 0 5px / 16px 2px no-repeat,
          linear-gradient(#234964, #234964) 0 10px / 16px 2px no-repeat;
      }
      .alert-dot {
        position: absolute;
        top: 3px;
        right: 3px;
        width: 9px;
        height: 9px;
        border-radius: 50%;
        background: #d92b2b;
        border: 1px solid #ffffff;
        display: none;
      }
      .alert-dot.show { display: block; }
      .logout { background: #f0f4f8; color: #27425b; border: 1px solid var(--border); }
      .overlay {
        position: fixed;
        inset: 0;
        background: rgba(9, 24, 37, .22);
        opacity: 0;
        pointer-events: none;
        transition: opacity .2s ease;
        z-index: 20;
      }
      .overlay.open {
        opacity: 1;
        pointer-events: auto;
      }
      .drawer {
        position: fixed;
        top: 0;
        right: -320px;
        width: min(320px, 85vw);
        height: 100vh;
        background: linear-gradient(180deg, #f8fcff, #edf4fa);
        border-left: 1px solid var(--border);
        box-shadow: -14px 0 28px rgba(13, 34, 52, .18);
        padding: .9rem;
        z-index: 30;
        transition: right .22s ease;
      }
      .drawer.open { right: 0; }
      .drawer-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: .7rem;
      }
      .drawer-title {
        margin: 0;
        font-size: .98rem;
        color: #244862;
      }
      .close-drawer {
        width: 2rem;
        height: 2rem;
        border: 1px solid var(--border);
        background: #f7fbff;
        color: #335a76;
      }
      .drawer-nav {
        display: grid;
        gap: .5rem;
      }
      .nav-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        border: 1px solid #c9dcec;
        background: #e8f2fb;
        color: #1f4b67;
        border-radius: 10px;
        padding: .6rem .7rem;
        min-height: 44px;
      }
      .nav-item.active {
        background: #d4e9f8;
        border-color: #9dc8e4;
      }
      .card {
        background: linear-gradient(180deg, var(--panel) 0%, #f9fcff 100%);
        border: 1px solid var(--border);
        border-radius: 18px;
        box-shadow: 0 14px 32px rgba(15, 42, 66, .09);
        padding: 1rem;
      }
      .view { display: none; }
      .view.active { display: block; }
      .section-title { margin: .1rem 0 .35rem; font-size: 1.07rem; }
      .field { display: grid; gap: .35rem; margin-bottom: .7rem; }
      label { font-size: .84rem; color: #3f5469; letter-spacing: .01em; }
      input, select, textarea {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: .6rem .65rem;
        font-size: 16px;
        background: #ffffff;
        min-height: 44px;
      }
      input:focus, select:focus, textarea:focus {
        outline: none;
        border-color: #8ab9de;
        box-shadow: 0 0 0 3px rgba(90, 159, 210, .18);
      }
      textarea { min-height: 115px; resize: vertical; }
      .row { display: flex; gap: .5rem; }
      .row > * { flex: 1; }
      .chat-toolbar {
        display: flex;
        gap: .5rem;
        align-items: flex-end;
        margin-bottom: .55rem;
      }
      .chat-toolbar .field { margin-bottom: 0; }
      .mode-wrap {
        position: relative;
        min-width: 220px;
      }
      .mode-button {
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border: 1px solid var(--border);
        background: #f4f8fc;
        color: #213f57;
        padding: .58rem .65rem;
      }
      .mode-button .caret {
        font-size: .72rem;
        opacity: .8;
      }
      .mode-panel {
        position: absolute;
        right: 0;
        top: calc(100% + 6px);
        z-index: 5;
        width: min(320px, 82vw);
        border: 1px solid var(--border);
        border-radius: 12px;
        background: #ffffff;
        box-shadow: 0 12px 24px rgba(21, 45, 66, .16);
        padding: .35rem;
      }
      .mode-panel[hidden] { display: none; }
      .mode-option {
        width: 100%;
        border: 1px solid transparent;
        border-radius: 10px;
        background: transparent;
        text-align: left;
        color: #1f364b;
        padding: .5rem .55rem;
        margin: .08rem 0;
      }
      .mode-option:hover {
        border-color: #c9dced;
        background: #f2f8fd;
      }
      .mode-option.active {
        border-color: #98c0de;
        background: #e8f3fc;
      }
      .mode-option .line1 {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 700;
      }
      .mode-option .line2 {
        color: var(--muted);
        font-size: .82rem;
        margin-top: .1rem;
      }
      .mode-check {
        color: #1f845a;
        font-size: .85rem;
      }
      .btn-primary { background: var(--accent); color: #fff; }
      .btn-primary:hover { background: var(--accent2); box-shadow: 0 8px 16px rgba(12, 93, 146, .2); }
      .btn-ghost { background: #f3f6fa; color: #24384f; border: 1px solid var(--border); }
      .btn-ghost:hover { background: #e9f0f7; }
      .chat-view { gap: .65rem; }
      .view.chat-view { display: none; }
      .view.active.chat-view { display: grid; }
      .chat-layout {
        display: grid;
        grid-template-columns: 260px minmax(0, 1fr);
        gap: .65rem;
      }
      .chat-layout.history-collapsed {
        grid-template-columns: 1fr;
      }
      .chat-layout.history-collapsed .thread-panel {
        display: none;
      }
      .thread-panel {
        border: 1px solid #d5e1ec;
        border-radius: 14px;
        background: linear-gradient(180deg, #f7fbff 0%, #edf4fb 100%);
        padding: .6rem;
      }
      .thread-panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: .45rem;
      }
      .thread-panel-header .section-title { margin: 0; }
      .thread-panel .muted { font-size: .8rem; }
      .thread-actions {
        display: flex;
        gap: .35rem;
        margin: .35rem 0 .5rem;
      }
      .thread-list {
        display: grid;
        gap: .35rem;
        max-height: 560px;
        overflow-y: auto;
      }
      .thread-item {
        width: 100%;
        text-align: left;
        border: 1px solid #cbdcec;
        background: #ffffff;
        color: #223a51;
        border-radius: 10px;
        padding: .5rem .55rem;
      }
      .thread-item.active {
        background: #e7f3fc;
        border-color: #99c0de;
      }
      .thread-item .line1 {
        font-size: .85rem;
        font-weight: 700;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .thread-item .line2 {
        font-size: .76rem;
        color: var(--muted);
        margin-top: .12rem;
      }
      .chat-surface {
        border: 1px solid #d6e1ec;
        background: linear-gradient(180deg, var(--surface-1) 0%, var(--surface-2) 100%);
        border-radius: 14px;
        padding: .7rem;
      }
      .composer {
        display: flex;
        align-items: center;
        gap: .45rem;
        border: 1px solid #c5d7e8;
        border-radius: 999px;
        background: #ffffff;
        box-shadow: 0 7px 14px rgba(10, 30, 48, .09);
        padding: .35rem .4rem;
        margin: .1rem 0 .25rem;
      }
      .composer-btn {
        width: 2.1rem;
        height: 2.1rem;
        border-radius: 999px;
        border: 1px solid transparent;
        background: transparent;
        color: #2a4b67;
        font-size: 1.2rem;
        line-height: 1;
        padding: 0;
      }
      .composer-btn:hover { background: #eef5fb; border-color: #d4e3f0; }
      .composer-btn.voice {
        font-size: .72rem;
        font-weight: 700;
        border-color: #d8e6f3;
        background: #f3f8fd;
      }
      .composer-btn.voice.listening {
        background: #ffe8d7;
        border-color: #ffd0ad;
        color: #8d4c0d;
      }
      .composer-send {
        width: 2.1rem;
        height: 2.1rem;
        border-radius: 999px;
        background: #111111;
        color: #ffffff;
        font-size: .72rem;
        font-weight: 700;
        padding: 0;
      }
      .composer-send:hover { background: #000000; }
      .composer-input {
        flex: 1;
        border: none;
        outline: none;
        font-size: 16px;
        background: transparent;
        min-width: 0;
        min-height: 38px;
      }
      .composer-input::placeholder { color: #7a8b9b; }
      .composer-tools {
        display: inline-flex;
        align-items: center;
        gap: .25rem;
      }
      .composer-hint {
        color: var(--muted);
        font-size: .78rem;
        margin: .1rem 0 .25rem .2rem;
      }
      .chat-controls {
        display: flex;
        gap: .55rem;
        align-items: end;
        flex-wrap: wrap;
      }
      .chat-controls .field { margin-bottom: 0; min-width: 210px; }
      .chat-quick-actions {
        margin-left: auto;
        display: inline-flex;
        gap: .45rem;
      }
      .notice { min-height: 1.2rem; font-size: .86rem; margin-top: .25rem; color: var(--muted); }
      .notice.ok { color: var(--ok); }
      .notice.warn { color: var(--warn); }
      .notice.error { color: var(--error); }
      .status {
        display: inline-flex;
        align-items: center;
        gap: .4rem;
        font-size: .82rem;
        padding: .2rem .45rem;
        border-radius: 999px;
        border: 1px solid #bfd6e8;
        background: #ecf5fb;
        color: #275372;
      }
      .status.ok { border-color: #b8decb; background: #e9f8ef; color: #1f6848; }
      .status.warn { border-color: #e1d0b1; background: #fdf5e8; color: #8b5310; }
      .grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: .65rem; }
      .chat-answer {
        margin-top: .2rem;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: #f7fbff;
        padding: .78rem;
      }
      .chat-thread-title {
        margin: 0 0 .45rem;
        color: #30526e;
        font-size: .88rem;
      }
      .chat-thread-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: .5rem;
        margin-bottom: .45rem;
      }
      .chat-thread-row .chat-thread-title { margin: 0; }
      .chat-history-toggle {
        flex: 0 0 auto;
        min-height: 34px;
        padding: .35rem .55rem;
        border-radius: 9px;
        border: 1px solid var(--border);
        background: #f3f7fc;
        color: #28465f;
        font-size: .78rem;
      }
      .chat-history-open {
        display: none;
      }
      .chat-layout.history-collapsed .chat-history-open {
        display: inline-flex;
      }
      .agent-status {
        display: flex;
        flex-wrap: wrap;
        gap: .35rem;
        margin-top: .28rem;
      }
      .agent-chip {
        border: 1px solid #c6d9ea;
        background: #edf5fc;
        color: #264d69;
        border-radius: 999px;
        padding: .22rem .5rem;
        font-size: .76rem;
        line-height: 1.1;
      }
      .agent-chip.active {
        border-color: #96c3e3;
        background: #d9ebf9;
      }
      .agent-chip.done {
        border-color: #b7dec7;
        background: #e9f8ef;
        color: #1d6947;
      }
      .chat-answer h1, .chat-answer h2, .chat-answer h3, .chat-answer h4 {
        margin: .55rem 0 .35rem;
      }
      .chat-answer p { margin: .45rem 0; line-height: 1.5; }
      .chat-answer ul { margin: .25rem 0 .5rem 1.1rem; }
      .chat-answer li { margin: .2rem 0; }
      .chat-log {
        border: 1px solid var(--border);
        border-radius: 10px;
        background: #f8fbff;
        min-height: 180px;
        max-height: 360px;
        overflow-y: auto;
        padding: .6rem;
      }
      .bubble {
        max-width: 85%;
        margin: .35rem 0;
        padding: .5rem .65rem;
        border-radius: 10px;
        line-height: 1.35;
        font-size: .9rem;
      }
      .bubble.coach {
        background: #e7f1fb;
        color: #204a66;
        border: 1px solid #c8deef;
      }
      .bubble.user {
        margin-left: auto;
        background: #dff3e8;
        color: #1f5f41;
        border: 1px solid #bde0cd;
      }
      .table {
        width: 100%;
        border-collapse: collapse;
        margin-top: .4rem;
      }
      .table-wrap {
        width: 100%;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }
      .table th, .table td {
        border-bottom: 1px solid #e7edf4;
        padding: .45rem;
        text-align: left;
        font-size: .86rem;
      }
      .intake-chat-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: .5rem;
      }
      .intake-chat-expand {
        min-height: 34px;
        padding: .32rem .55rem;
        border-radius: 9px;
        border: 1px solid var(--border);
        background: #f3f7fc;
        color: #28465f;
        font-size: .78rem;
      }
      #intake-chat-log {
        min-height: 220px;
        max-height: 360px;
      }
      #intake-chat-log.expanded {
        min-height: 380px;
        max-height: 68vh;
      }
      .hint { font-size: .84rem; color: var(--muted); margin-top: .3rem; }
      @media (max-width: 900px) {
        .grid-2 { grid-template-columns: 1fr; }
        .topbar { border-radius: 13px; }
      }
      @media (max-width: 680px) {
        .shell {
          max-width: 560px;
          min-height: 100vh;
          padding: .72rem .62rem calc(1rem + env(safe-area-inset-bottom));
        }
        .card {
          border-radius: 16px;
          padding: .72rem;
        }
        .topbar {
          align-items: flex-start;
          flex-wrap: wrap;
          gap: .65rem;
        }
        .top-actions {
          width: 100%;
          justify-content: flex-end;
        }
        .row {
          flex-wrap: wrap;
        }
        .row > * {
          min-width: 140px;
        }
        .drawer {
          width: min(360px, 92vw);
        }
        .chat-controls {
          flex-direction: column;
          align-items: stretch;
        }
        .chat-layout {
          grid-template-columns: 1fr;
        }
        .thread-panel {
          order: 2;
        }
        .chat-layout.history-collapsed .thread-panel {
          display: none;
        }
        .chat-controls .field,
        .chat-quick-actions {
          width: 100%;
          margin-left: 0;
        }
        .chat-quick-actions {
          display: flex;
          gap: .45rem;
        }
        .composer {
          gap: .35rem;
          padding: .3rem .35rem;
        }
        .composer-btn,
        .composer-send {
          width: 2.2rem;
          height: 2.2rem;
        }
        .table th, .table td {
          white-space: nowrap;
        }
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <div class="topbar">
        <div>
          <h1 class="title">Longevity Workspace</h1>
          <p class="muted" id="welcome">Loading session...</p>
        </div>
        <div class="top-actions">
          <button class="hamburger" id="menu-toggle" aria-label="Open menu">
            <span class="icon-bars" aria-hidden="true"></span>
            <span class="alert-dot" id="intake-alert-dot" aria-hidden="true"></span>
          </button>
          <button class="logout" id="logout">Log Out</button>
        </div>
      </div>
      <div class="overlay" id="menu-overlay"></div>
      <aside class="drawer" id="menu-drawer">
        <div class="drawer-header">
          <h3 class="drawer-title">Workspace Menu</h3>
          <button class="close-drawer" id="menu-close" aria-label="Close menu">x</button>
        </div>
        <div class="drawer-nav">
          <button id="menu-chat" class="nav-item active"><span>Chat</span></button>
          <button id="menu-summary" class="nav-item"><span>Overall Summary</span></button>
          <button id="menu-intake" class="nav-item"><span>Intake</span><span id="intake-badge" class="status warn">pending</span></button>
          <button id="menu-settings" class="nav-item"><span>Settings</span></button>
          <button id="menu-usage" class="nav-item"><span>Model Usage</span></button>
          <button id="menu-feedback" class="nav-item"><span>Feedback</span></button>
        </div>
      </aside>

      <section class="card">
        <article id="view-chat" class="view active chat-view">
  <h2 class="section-title">Default Chat</h2>
  <p class="muted">Ask a coaching question anytime. Mode controls response depth: Quick is faster, Deep is more thorough.</p>
  <div class="chat-layout">
    <aside class="thread-panel">
      <div class="thread-panel-header">
        <h3 class="section-title" style="font-size:.96rem;">Chat History</h3>
        <button class="chat-history-toggle" id="chat-history-hide" type="button" aria-expanded="true">Hide</button>
      </div>
      <p class="muted">Select prior threads or start a new chat.</p>
      <div class="thread-actions">
        <button class="btn-primary" id="chat-new-thread" type="button">New</button>
        <button class="btn-ghost" id="chat-refresh-threads" type="button">Refresh</button>
      </div>
      <div id="chat-thread-list" class="thread-list"></div>
    </aside>
    <div class="chat-surface">
      <div class="chat-thread-row">
        <p id="chat-thread-title" class="chat-thread-title">Current thread: New chat</p>
        <button class="chat-history-toggle chat-history-open" id="chat-history-show" type="button" aria-expanded="false">Show History</button>
      </div>
      <div class="field">
        <label for="chat-question">Question</label>
        <div class="composer">
          <input id="chat-image-file" type="file" accept="image/*" style="display:none;" />
          <button class="composer-btn" id="chat-image" type="button" aria-label="Attach image">+</button>
          <input id="chat-question" class="composer-input" type="text" placeholder="Ask anything" autocomplete="off" />
          <div class="composer-tools">
            <button class="composer-btn voice" id="chat-voice" type="button" aria-label="Voice input">Mic</button>
            <button class="composer-send" id="chat-send" type="button" aria-label="Send">Go</button>
          </div>
        </div>
        <div class="composer-hint">Enter to send. Shift+Enter for newline where supported.</div>
      </div>
              <div class="chat-controls">
                <div class="field">
                  <label>Mode</label>
                  <div class="mode-wrap">
            <button class="mode-button" id="chat-mode-button" aria-haspopup="true" aria-expanded="false" type="button">
              <span id="chat-mode-label">Auto</span>
              <span class="caret">v</span>
            </button>
            <div class="mode-panel" id="chat-mode-panel" hidden>
              <button class="mode-option active" type="button" data-mode="auto">
                <span class="line1">Auto <span class="mode-check">ok</span></span>
                <span class="line2">Chooses Quick or Deep from question complexity.</span>
              </button>
              <button class="mode-option" type="button" data-mode="quick">
                <span class="line1">Quick <span class="mode-check" hidden>ok</span></span>
                <span class="line2">Faster response with concise analysis.</span>
              </button>
              <button class="mode-option" type="button" data-mode="deep">
                <span class="line1">Deep <span class="mode-check" hidden>ok</span></span>
                <span class="line2">Uses Deep Thinker for broader reasoning.</span>
              </button>
            </div>
                  </div>
                </div>
                <div class="field">
                  <label for="chat-web-search">Research</label>
                  <select id="chat-web-search">
                    <option value="on" selected>Web Search On</option>
                    <option value="off">Web Search Off</option>
                  </select>
                </div>
                <div class="chat-quick-actions">
                  <button class="btn-ghost" id="chat-daily-summary">Daily Summary</button>
                  <button class="btn-ghost" id="chat-daily-plan">Daily Plan</button>
                  <button class="btn-ghost" id="chat-what-next">What Next</button>
                  <button class="btn-ghost" id="chat-clear">Clear</button>
                  <button class="btn-ghost" id="chat-daily-start">Check In</button>
                  <button class="btn-ghost" id="chat-daily-cancel" style="display:none;">Cancel Check In</button>
                </div>
              </div>
      <div class="notice" id="chat-notice"></div>
      <div id="chat-agent-status" class="agent-status"></div>
      <div class="field">
        <label>Conversation</label>
        <div id="chat-log" class="chat-log"></div>
      </div>
      <div id="chat-answer" class="chat-answer" style="display:none;"></div>
    </div>
  </div>
</article>

        <article id="view-intake" class="view">
          <h2 class="section-title">Intake Coach</h2>
          <p class="muted">Complete intake through a guided coach chat. Answer naturally with your preferred units (lb/kg, in/cm, etc.).</p>
          <div class="notice" id="intake-status"></div>
          <div class="field">
            <label for="intake-top-goals">Top Goals (optional starter)</label>
            <input id="intake-top-goals" type="text" placeholder="energy, sleep, weight loss" />
          </div>
          <div class="row">
            <button class="btn-primary" id="intake-start">Start / Resume Intake Coach</button>
            <button class="btn-ghost" id="intake-refresh">Refresh Status</button>
          </div>
          <div class="field">
            <div class="intake-chat-header">
              <label>Coach Chat</label>
              <button type="button" id="intake-chat-expand" class="intake-chat-expand">Expand</button>
            </div>
            <div id="intake-chat-log" class="chat-log"></div>
          </div>
          <div class="field">
            <label for="intake-answer">Your Answer</label>
            <textarea id="intake-answer" placeholder="Type answer for current intake question"></textarea>
          </div>
          <div class="row">
            <button class="btn-primary" id="intake-answer-send">Send Answer</button>
            <button class="btn-ghost" id="intake-complete" style="display:none;">Finalize Intake</button>
          </div>
          <div class="notice" id="intake-notice"></div>
        </article>

        <article id="view-summary" class="view">
          <h2 class="section-title">Overall Summary</h2>
          <p class="muted">Snapshot of today plus 7-day and 30-day trends from your daily logs.</p>
          <div class="row">
            <button class="btn-primary" id="summary-refresh">Refresh Summary</button>
          </div>
          <div class="chat-answer" id="summary-health" style="margin-top:.7rem;">No health score yet.</div>
          <div class="grid-2" style="margin-top:.6rem;">
            <div class="chat-answer" id="summary-today">No summary yet.</div>
            <div class="chat-answer" id="summary-trends">No summary yet.</div>
          </div>
          <div class="chat-answer" id="summary-insights" style="margin-top:.7rem;">No summary yet.</div>
          <div class="notice" id="summary-notice"></div>
        </article>

        <article id="view-settings" class="view">
          <h2 class="section-title">Settings</h2>
          <p class="muted">Update AI settings or change password from this menu at any time.</p>
          <p class="hint">Model pricing shown here uses provider list rates (OpenAI API Pricing and Gemini API Pricing), last synced on February 15, 2026.</p>
          <div class="grid-2">
            <div>
              <h3 class="section-title">AI Settings</h3>
              <div class="field"><label for="provider">Provider</label><select id="provider"><option value="">Select provider</option><option value="openai">OpenAI (ChatGPT)</option><option value="gemini">Gemini</option></select></div>
              <div class="field"><label for="api-key">API Key</label><input id="api-key" type="password" placeholder="Required for first-time setup" /><div class="hint" id="api-key-mask"></div></div>
              <div class="field"><label for="deep-model">Deep Thinker Model</label><select id="deep-model"><option value="">Select model</option></select></div>
              <div class="field"><label for="reason-model">Reasoning Model</label><select id="reason-model"><option value="">Select model</option></select></div>
              <div class="field"><label for="utility-model">Utility Model</label><select id="utility-model"><option value="">Select model</option></select></div>
              <div class="row"><button class="btn-primary" id="ai-save">Save AI Settings</button><button class="btn-ghost" id="ai-load">Load Current</button></div>
              <div class="notice" id="ai-notice"></div>
            </div>
            <div>
              <h3 class="section-title">Password</h3>
              <div class="field"><label for="current-password">Current Password</label><input id="current-password" type="password" /></div>
              <div class="field"><label for="new-password">New Password</label><input id="new-password" type="password" /></div>
              <button class="btn-primary" id="password-save">Change Password</button>
              <div class="notice" id="password-notice"></div>
              <h3 class="section-title" style="margin-top:1rem;">Reminder Notifications</h3>
              <div class="field">
                <label for="notify-enabled">Enable reminders</label>
                <select id="notify-enabled">
                  <option value="off">Off</option>
                  <option value="on">On</option>
                </select>
              </div>
              <div class="field">
                <label for="notify-interval">Reminder interval (minutes)</label>
                <input id="notify-interval" type="number" min="15" max="1440" value="120" />
              </div>
              <div class="row">
                <button class="btn-primary" id="notify-save">Save Reminder Settings</button>
                <button class="btn-ghost" id="notify-permission">Enable Browser Notifications</button>
              </div>
              <div class="row">
                <button class="btn-ghost" id="notify-test">Send Test Reminder</button>
              </div>
              <div class="notice" id="notify-notice"></div>
              <h3 class="section-title" style="margin-top:1rem;">Data Reset</h3>
              <div class="row">
                <button class="btn-ghost" id="reset-daily-data">Clear Daily Logs</button>
                <button class="btn-ghost" id="reset-user-data">Reinitialize User Data</button>
                <button class="btn-ghost" id="reset-model-usage">Reset Model Stats</button>
              </div>
              <div class="notice" id="reset-notice"></div>
            </div>
          </div>
        </article>

        <article id="view-usage" class="view">
          <h2 class="section-title">Model Token Usage</h2>
          <p class="muted">Token usage is tracked per user/provider/model for visibility and cost control.</p>
          <button class="btn-ghost" id="usage-refresh">Refresh</button>
          <div class="table-wrap">
            <table class="table" id="usage-table">
              <thead><tr><th>Provider</th><th>Model</th><th>Requests</th><th>Prompt</th><th>Completion</th><th>Total</th><th>Rough Cost (USD)</th></tr></thead>
              <tbody></tbody>
            </table>
          </div>
          <div class="hint" id="usage-hint"></div>
        </article>

        <article id="view-feedback" class="view">
          <h2 class="section-title">Feature Ideas And Bug Capture</h2>
          <p class="muted">Capture new feature ideas, bugs, and product suggestions. Entries are shared across users for centralized review.</p>
          <div class="grid-2">
            <div>
              <div class="field">
                <label for="feedback-category">Type</label>
                <select id="feedback-category">
                  <option value="feature">Feature</option>
                  <option value="idea">Idea</option>
                  <option value="bug">Bug</option>
                </select>
              </div>
              <div class="field">
                <label for="feedback-title">Title</label>
                <input id="feedback-title" type="text" placeholder="Short title" />
              </div>
              <div class="field">
                <label for="feedback-details">Details</label>
                <textarea id="feedback-details" placeholder="What happened or what should be added?"></textarea>
              </div>
              <div class="field">
                <label for="feedback-page">Where in app? (optional)</label>
                <input id="feedback-page" type="text" placeholder="chat, intake, settings..." />
              </div>
              <div class="row">
                <button class="btn-primary" id="feedback-submit">Submit Entry</button>
                <button class="btn-ghost" id="feedback-clear-form">Clear Form</button>
              </div>
            </div>
            <div>
              <h3 class="section-title">Data Actions</h3>
              <p class="muted">Export all captured entries to CSV or clear all entries from the shared list.</p>
              <div class="row">
                <button class="btn-ghost" id="feedback-export">Export CSV</button>
                <button class="btn-ghost" id="feedback-clear-all">Clear All Entries</button>
              </div>
            </div>
          </div>
          <div class="notice" id="feedback-notice"></div>
        </article>
      </section>
    </div>

    <script>
      const token = sessionStorage.getItem("access_token") || "";
      if (!token) window.location.href = "/onboarding";

      const el = (id) => document.getElementById(id);
      const views = ["chat", "summary", "intake", "settings", "usage", "feedback"];
      const intakeState = { sessionId: null, readyToComplete: false };
      const intakeChat = [];
      const intakeUiState = { chatExpanded: false };
      let speechRecognition = null;
      let voiceListening = false;
      let selectedChatImage = null;
      const dailyCheckin = {
        active: false,
        index: 0,
        logDate: null,
        payload: {},
        metricPayloads: [],
        extras: {},
        answers: {},
        evidence: {},
        profile: { goalFocus: "general", primaryGoal: "", topGoals: [] },
        timeBucket: "morning",
        intro: "",
        latestSummaryMarkdown: "",
        steps: []
      };
      const DAILY_CORE_STEPS = [
        { key: "sleep_hours", label: "Sleep Hours", specialist: "Sleep Expert", question: "How many hours did you sleep last night?", type: "float", min: 0, max: 16 },
        { key: "energy", label: "Energy", specialist: "Recovery & Stress Regulator", question: "On a 1-10 scale, what is your energy today?", type: "int", min: 1, max: 10 },
        { key: "mood", label: "Mood", specialist: "Behavior Architect", question: "On a 1-10 scale, what is your mood today?", type: "int", min: 1, max: 10 },
        { key: "stress", label: "Stress", specialist: "Recovery & Stress Regulator", question: "On a 1-10 scale, what is your stress today?", type: "int", min: 1, max: 10 },
        { key: "training_done", label: "Training Done", specialist: "Movement Coach", question: "Did you complete training today? (yes/no)", type: "bool" },
        { key: "nutrition_on_plan", label: "Food Logged", specialist: "Nutritionist", question: "Did you log your food intake today? (yes/no)", type: "bool" }
      ];
      const DAILY_PAYLOAD_KEYS = new Set(["sleep_hours", "energy", "mood", "stress", "training_done", "nutrition_on_plan", "notes"]);
      const DAILY_OPTIONAL_SIGNAL_STEP = {
        key: "tracked_signals",
        label: "Optional Signals",
        specialist: "Orchestrator",
        question: "Which optional signals did you track today? (comma separated: weight, blood pressure, bed/wake times, last meal time, none)",
        type: "signals"
      };
      const DAILY_OPTIONAL_STEPS = {
        weight: { key: "weight_kg", label: "Weight", specialist: "Cardiometabolic Strategist", question: "What was your weight this morning? (kg or lbs)", type: "weight" },
        bp: { key: "bp", label: "Blood Pressure", specialist: "Cardiometabolic Strategist", question: "What was your blood pressure reading? (e.g., 120/80)", type: "bp" },
        sleep_timing: { key: "sleep_timing", label: "Sleep Timing", specialist: "Sleep Expert", question: "What time did you go to bed and wake up? (e.g., 11:00pm, 6:30am)", type: "text" },
        last_meal: { key: "last_meal", label: "Last Meal Time", specialist: "Nutritionist", question: "What time was your last meal?", type: "text" }
      };
      const DAILY_NOTES_STEP = { key: "notes", label: "Notes", specialist: "Goal Strategist", question: "Any short note for today? (type 'skip' to skip)", type: "text" };
      const DAILY_NUTRITION_LOG_CHOICE_STEP = {
        key: "nutrition_log_choice",
        label: "Nutrition Log Choice",
        specialist: "Nutritionist",
        question: "Would you like to log food now or later? (now/later)",
        type: "text"
      };
      const DAILY_NUTRITION_LOG_DETAILS_STEP = {
        key: "nutrition_food_details",
        label: "Food Details",
        specialist: "Nutritionist",
        question: "Please log what you ate so far (include rough portions).",
        type: "text"
      };
      const CHAT_MODE_PRESETS = {
        auto: { label: "Auto", mode: "quick", deepThink: false },
        quick: { label: "Quick", mode: "quick", deepThink: false },
        deep: { label: "Deep", mode: "deep", deepThink: true }
      };
      let selectedChatMode = "auto";
      const chatState = {
        currentThreadId: null,
        threads: [],
        messages: [],
        progressTimer: null,
      };
      const chatUiState = {
        historyCollapsed: false,
      };
      const reminderState = {
        enabled: false,
        intervalMinutes: 120,
        timerId: null,
        title: "Longevity Check-In",
        body: "Quick check-in: log your progress and keep momentum."
      };
      const busyState = {
        chat: 0,
        intake: 0,
        checkin: 0,
      };
      let intakePrimaryGoal = "";

      function authHeaders() {
        return { "Authorization": "Bearer " + token, "Content-Type": "application/json" };
      }

      function setNotice(id, text, kind) {
        const node = el(id);
        node.textContent = text || "";
        node.className = "notice" + (kind ? " " + kind : "");
      }

      function setBusy(scope, isBusy, label) {
        const key = String(scope || "");
        if (!Object.prototype.hasOwnProperty.call(busyState, key)) return;
        if (isBusy) busyState[key] += 1;
        else busyState[key] = Math.max(0, busyState[key] - 1);
        const active = busyState[key] > 0;

        if (key === "chat") {
          const sendBtn = el("chat-send");
          const voiceBtn = el("chat-voice");
          const imgBtn = el("chat-image");
          if (sendBtn) {
            sendBtn.disabled = active;
            sendBtn.textContent = active ? (label || "Working...") : "Go";
          }
          if (voiceBtn) voiceBtn.disabled = active;
          if (imgBtn) imgBtn.disabled = active;
        } else if (key === "intake") {
          const sendBtn = el("intake-answer-send");
          const startBtn = el("intake-start");
          const completeBtn = el("intake-complete");
          if (sendBtn) {
            sendBtn.disabled = active;
            sendBtn.textContent = active ? (label || "Working...") : "Send Answer";
          }
          if (startBtn) {
            startBtn.disabled = active;
            startBtn.textContent = active ? "Working..." : "Start / Resume Intake Coach";
          }
          if (completeBtn) {
            completeBtn.disabled = active;
            if (!active) completeBtn.textContent = "Finalize Intake";
          }
        } else if (key === "checkin") {
          const startBtn = el("chat-daily-start");
          if (startBtn) {
            startBtn.disabled = active;
            startBtn.textContent = active ? (label || "Check In (Working...)") : "Check In";
          }
        }
      }

      function notificationSupported() {
        return typeof window !== "undefined" && "Notification" in window;
      }

      function clearReminderTimer() {
        if (reminderState.timerId) {
          clearInterval(reminderState.timerId);
          reminderState.timerId = null;
        }
      }

      function showReminderNotification() {
        if (!notificationSupported()) return;
        if (Notification.permission !== "granted") return;
        const title = reminderState.title || "Longevity Check-In";
        const body = reminderState.body || "Quick check-in: log your progress and keep momentum.";
        const n = new Notification(title, { body });
        n.onclick = () => {
          window.focus();
          showView("chat");
        };
      }

      function scheduleReminderTimer() {
        clearReminderTimer();
        if (!reminderState.enabled) return;
        if (!notificationSupported() || Notification.permission !== "granted") {
          setNotice("notify-notice", "Reminders saved, but browser notification permission is not granted.", "warn");
          return;
        }
        const intervalMs = Math.max(15, Number(reminderState.intervalMinutes || 120)) * 60 * 1000;
        reminderState.timerId = setInterval(showReminderNotification, intervalMs);
      }

      function escapeHtml(value) {
        return String(value || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function renderSimpleMarkdown(markdownText) {
        const src = String(markdownText || "").replace(/\r\n/g, "\n");
        const lines = src.split("\n");
        let html = "";
        let inList = false;
        for (const rawLine of lines) {
          const line = rawLine.trimEnd();
          if (!line.trim()) {
            if (inList) {
              html += "</ul>";
              inList = false;
            }
            continue;
          }
          const hMatch = line.match(/^(#{1,4})\s+(.*)$/);
          if (hMatch) {
            if (inList) {
              html += "</ul>";
              inList = false;
            }
            const level = Math.min(4, hMatch[1].length);
            let content = escapeHtml(hMatch[2]);
            content = content.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
            html += "<h" + level + ">" + content + "</h" + level + ">";
            continue;
          }
          const liMatch = line.match(/^[-*]\s+(.*)$/);
          if (liMatch) {
            if (!inList) {
              html += "<ul>";
              inList = true;
            }
            let item = escapeHtml(liMatch[1]);
            item = item.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
            html += "<li>" + item + "</li>";
            continue;
          }
          if (inList) {
            html += "</ul>";
            inList = false;
          }
          let paragraph = escapeHtml(line);
          paragraph = paragraph.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
          paragraph = paragraph.replace(/`([^`]+?)`/g, "<code>$1</code>");
          html += "<p>" + paragraph + "</p>";
        }
        if (inList) html += "</ul>";
        return html || "<p>No answer content.</p>";
      }

      function toggleIntakeChatExpanded() {
        const log = el("intake-chat-log");
        const btn = el("intake-chat-expand");
        if (!log || !btn) return;
        intakeUiState.chatExpanded = !intakeUiState.chatExpanded;
        log.classList.toggle("expanded", intakeUiState.chatExpanded);
        btn.textContent = intakeUiState.chatExpanded ? "Collapse" : "Expand";
      }

      function addIntakeChatMessage(role, text) {
        if (!text) return;
        intakeChat.push({ role, text });
        const log = el("intake-chat-log");
        const bubble = document.createElement("div");
        bubble.className = "bubble " + role;
        if (role === "coach") {
          bubble.innerHTML = renderSimpleMarkdown(text);
        } else {
          bubble.innerHTML = "<p>" + escapeHtml(text) + "</p>";
        }
        log.appendChild(bubble);
        log.scrollTop = log.scrollHeight;
      }

      function showView(name) {
        views.forEach((v) => {
          el("view-" + v).classList.toggle("active", v === name);
          el("menu-" + v).classList.toggle("active", v === name);
        });
        closeDrawer();
      }

      function openDrawer() {
        el("menu-drawer").classList.add("open");
        el("menu-overlay").classList.add("open");
      }

      function closeDrawer() {
        el("menu-drawer").classList.remove("open");
        el("menu-overlay").classList.remove("open");
      }

      function toggleDrawer() {
        if (el("menu-drawer").classList.contains("open")) {
          closeDrawer();
        } else {
          openDrawer();
        }
      }

      function openModePanel() {
        el("chat-mode-panel").hidden = false;
        el("chat-mode-button").setAttribute("aria-expanded", "true");
      }

      function closeModePanel() {
        el("chat-mode-panel").hidden = true;
        el("chat-mode-button").setAttribute("aria-expanded", "false");
      }

      function toggleModePanel() {
        if (el("chat-mode-panel").hidden) openModePanel();
        else closeModePanel();
      }

      function applyModeSelection(modeKey) {
        selectedChatMode = CHAT_MODE_PRESETS[modeKey] ? modeKey : "auto";
        el("chat-mode-label").textContent = CHAT_MODE_PRESETS[selectedChatMode].label;
        document.querySelectorAll(".mode-option").forEach((node) => {
          const active = node.getAttribute("data-mode") === selectedChatMode;
          node.classList.toggle("active", active);
          const check = node.querySelector(".mode-check");
          if (check) check.hidden = !active;
        });
        closeModePanel();
      }

      function resolveChatMode(question) {
        if (selectedChatMode !== "auto") return CHAT_MODE_PRESETS[selectedChatMode];
        // Cost guardrail: default auto mode always runs quick path.
        return CHAT_MODE_PRESETS.quick;
      }

      function isWebSearchEnabled() {
        return (el("chat-web-search")?.value || "on") === "on";
      }

      function setChatThreadTitle() {
        const active = chatState.threads.find((t) => t.thread_id === chatState.currentThreadId);
        const title = active ? active.title : "New chat";
        el("chat-thread-title").textContent = "Current thread: " + title;
      }

      function renderChatThreads() {
        const list = el("chat-thread-list");
        list.innerHTML = "";
        if (!chatState.threads.length) {
          const empty = document.createElement("div");
          empty.className = "hint";
          empty.textContent = "No prior chats yet.";
          list.appendChild(empty);
          setChatThreadTitle();
          return;
        }
        chatState.threads.forEach((thread) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "thread-item" + (thread.thread_id === chatState.currentThreadId ? " active" : "");
          const count = Number(thread.message_count || 0);
          btn.innerHTML = "<div class=\"line1\">" + escapeHtml(thread.title || "Chat") + "</div>"
            + "<div class=\"line2\">" + count + " msgs</div>";
          btn.addEventListener("click", async () => {
            await loadThreadMessages(thread.thread_id);
          });
          list.appendChild(btn);
        });
        setChatThreadTitle();
      }

      function renderChatLog() {
        const log = el("chat-log");
        log.innerHTML = "";
        if (!chatState.messages.length) {
          const empty = document.createElement("div");
          empty.className = "hint";
          empty.textContent = "Start a question to create your first thread.";
          log.appendChild(empty);
          return;
        }
        chatState.messages.forEach((msg) => {
          const row = document.createElement("div");
          const role = String(msg.role || "");
          row.className = "bubble " + (role === "assistant" ? "coach" : "user");
          if (role === "assistant") {
            row.innerHTML = renderSimpleMarkdown(msg.content || "");
          } else {
            row.innerHTML = "<p>" + escapeHtml(msg.content || "") + "</p>";
          }
          log.appendChild(row);
        });
        log.scrollTop = log.scrollHeight;
      }

      function setHistoryCollapsed(collapsed, persist = true) {
        const layout = document.querySelector(".chat-layout");
        const hideBtn = el("chat-history-hide");
        const showBtn = el("chat-history-show");
        if (!layout || !hideBtn || !showBtn) return;
        chatUiState.historyCollapsed = !!collapsed;
        layout.classList.toggle("history-collapsed", chatUiState.historyCollapsed);
        hideBtn.textContent = "Hide";
        hideBtn.setAttribute("aria-expanded", chatUiState.historyCollapsed ? "false" : "true");
        showBtn.textContent = "Show History";
        showBtn.setAttribute("aria-expanded", chatUiState.historyCollapsed ? "false" : "true");
        if (persist) {
          try {
            sessionStorage.setItem("chat_history_collapsed", chatUiState.historyCollapsed ? "1" : "0");
          } catch (_) {
            // Ignore storage failures.
          }
        }
      }

      function toggleHistoryCollapsed() {
        setHistoryCollapsed(!chatUiState.historyCollapsed, true);
      }

      function initHistoryCollapsedState() {
        let saved = null;
        try {
          saved = sessionStorage.getItem("chat_history_collapsed");
        } catch (_) {
          saved = null;
        }
        if (saved === "1" || saved === "0") {
          setHistoryCollapsed(saved === "1", false);
          return;
        }
        const mobileDefault = window.matchMedia && window.matchMedia("(max-width: 900px)").matches;
        setHistoryCollapsed(!!mobileDefault, false);
      }

      async function loadChatThreads() {
        const res = await fetch("/chat/threads", { headers: { "Authorization": "Bearer " + token } });
        if (!res.ok) return;
        const body = await res.json();
        chatState.threads = Array.isArray(body.items) ? body.items : [];
        if (!chatState.currentThreadId && chatState.threads.length) {
          chatState.currentThreadId = chatState.threads[0].thread_id;
          await loadThreadMessages(chatState.currentThreadId);
          return;
        }
        renderChatThreads();
      }

      async function loadThreadMessages(threadId) {
        const res = await fetch("/chat/threads/" + threadId + "/messages", {
          headers: { "Authorization": "Bearer " + token }
        });
        if (!res.ok) {
          setNotice("chat-notice", "Could not load chat thread.", "error");
          return;
        }
        const body = await res.json();
        chatState.currentThreadId = body.thread_id;
        chatState.messages = Array.isArray(body.messages) ? body.messages : [];
        renderChatThreads();
        renderChatLog();
      }

      function startNewChat() {
        if (dailyCheckin.active) {
          cancelDailyCheckin("Check-in canceled for a new chat.");
        }
        chatState.currentThreadId = null;
        chatState.messages = [];
        el("chat-question").value = "";
        el("chat-answer").style.display = "none";
        el("chat-answer").innerHTML = "";
        el("chat-agent-status").innerHTML = "";
        setNotice("chat-notice", "New chat ready.", "ok");
        renderChatThreads();
        renderChatLog();
      }

      function buildAgentProgressPlan(question, resolved) {
        const q = String(question || "").toLowerCase();
        const goal = String(intakePrimaryGoal || "").toLowerCase();
        const includesSupplement = q.includes("supplement");
        const looksGoalStrategy = ["goal", "target", "milestone", "phase", "6 week", "12 week", "3 month", "6 month", "roadmap", "plan", "pivot", "stall", "objective"].some((k) => q.includes(k));
        const looksSleep = ["sleep", "wake", "tired", "fatigue", "recovery"].some((k) => q.includes(k));
        const looksNutrition = ["eat", "meal", "nutrition", "diet", "protein", "calorie", "supplement"].some((k) => q.includes(k));
        const looksMovement = ["train", "exercise", "steps", "workout", "cardio", "strength"].some((k) => q.includes(k));
        const looksCardioMeta = ["ldl", "hdl", "triglyceride", "cholesterol", "lipid", "bp", "blood pressure", "insulin"].some((k) => q.includes(k));
        const looksBehavior = ["habit", "adherence", "compliance", "consistency", "friction", "motivation", "routine"].some((k) => q.includes(k));
        const looksRecoveryStress = ["recovery", "stress", "hrv", "cortisol", "deload", "burnout", "alcohol"].some((k) => q.includes(k));
        const goalLooksWeight = ["weight", "fat", "metabolic", "body comp"].some((k) => goal.includes(k));
        const goalLooksCardio = ["heart", "bp", "blood pressure", "cholesterol", "lipid", "cardio"].some((k) => goal.includes(k));
        const goalLooksEnergy = ["energy", "fatigue", "recovery"].some((k) => goal.includes(k));
        const goalLooksClarity = ["mental", "clarity", "focus", "stress", "sleep"].some((k) => goal.includes(k));

        if (resolved.deepThink || resolved.mode === "deep") {
          const deepPlan = [];
          deepPlan.push({ id: "goal_strategist", label: "Goal Strategist" });
          deepPlan.push({ id: "nutritionist", label: "Nutritionist" });
          deepPlan.push({ id: "sleep_expert", label: "Sleep Expert" });
          if (looksMovement || goalLooksWeight) deepPlan.push({ id: "movement_coach", label: "Movement Coach" });
          deepPlan.push({ id: "cardiometabolic_strategist", label: "Cardiometabolic Strategist" });
          if (looksBehavior) deepPlan.push({ id: "behavior_architect", label: "Behavior Architect" });
          if (looksRecoveryStress || goalLooksEnergy || goalLooksClarity) deepPlan.push({ id: "recovery_stress_regulator", label: "Recovery & Stress Regulator" });
          if (includesSupplement) deepPlan.push({ id: "supplement_auditor", label: "Supplement Auditor" });
          deepPlan.push({ id: "safety_clinician", label: "Safety Clinician" });
          deepPlan.push({ id: "orchestrator", label: "Orchestrator" });
          return deepPlan;
        }
        const quickPlan = [];
        if (looksGoalStrategy || goalLooksWeight || goalLooksCardio || goalLooksEnergy || goalLooksClarity) {
          quickPlan.push({ id: "goal_strategist", label: "Goal Strategist" });
        }
        if (looksCardioMeta || goalLooksCardio) quickPlan.push({ id: "cardiometabolic_strategist", label: "Cardiometabolic Strategist" });
        if (looksNutrition || goalLooksWeight) quickPlan.push({ id: "nutritionist", label: "Nutritionist" });
        if (looksSleep || goalLooksEnergy || goalLooksClarity) quickPlan.push({ id: "sleep_expert", label: "Sleep Expert" });
        if (looksMovement || goalLooksWeight) quickPlan.push({ id: "movement_coach", label: "Movement Coach" });
        if (includesSupplement) quickPlan.push({ id: "supplement_auditor", label: "Supplement Auditor" });
        if (looksBehavior) quickPlan.push({ id: "behavior_architect", label: "Behavior Architect" });
        if (looksRecoveryStress || goalLooksEnergy || goalLooksClarity) quickPlan.push({ id: "recovery_stress_regulator", label: "Recovery & Stress Regulator" });
        quickPlan.push({ id: "safety_clinician", label: "Safety Clinician" });
        quickPlan.push({ id: "orchestrator", label: "Orchestrator" });
        const seen = new Set();
        return quickPlan.filter((node) => {
          if (seen.has(node.id)) return false;
          seen.add(node.id);
          return true;
        });
      }

      function renderAgentStatus(plan, activeId, doneIds) {
        const done = new Set(doneIds || []);
        const html = (plan || []).map((node) => {
          const stateClass = done.has(node.id) ? "done" : (activeId === node.id ? "active" : "");
          return "<span class=\"agent-chip " + stateClass + "\">" + escapeHtml(node.label) + "</span>";
        }).join("");
        el("chat-agent-status").innerHTML = html;
      }

      function currentDailyStep() {
        return dailyCheckin.steps[dailyCheckin.index] || null;
      }

      function detectGoalFocus(primaryGoal, topGoals) {
        const blob = (String(primaryGoal || "") + " " + String((topGoals || []).join(" "))).toLowerCase();
        if (blob.includes("energy") || blob.includes("fatigue")) return "energy";
        if (blob.includes("weight") || blob.includes("fat") || blob.includes("metabolic")) return "weight";
        if (blob.includes("heart") || blob.includes("bp") || blob.includes("blood pressure") || blob.includes("cardio")) return "heart";
        if (blob.includes("mental") || blob.includes("clarity") || blob.includes("focus")) return "clarity";
        return "general";
      }

      function orderedCoreStepsByGoal(focus) {
        const byKey = Object.fromEntries(DAILY_CORE_STEPS.map((s) => [s.key, s]));
        if (focus === "energy" || focus === "clarity") {
          return [byKey.sleep_hours, byKey.stress, byKey.energy, byKey.mood, byKey.training_done, byKey.nutrition_on_plan];
        }
        if (focus === "weight") {
          return [byKey.nutrition_on_plan, byKey.training_done, byKey.sleep_hours, byKey.energy, byKey.stress, byKey.mood];
        }
        if (focus === "heart") {
          return [byKey.stress, byKey.sleep_hours, byKey.training_done, byKey.nutrition_on_plan, byKey.energy, byKey.mood];
        }
        return DAILY_CORE_STEPS.slice();
      }

      function localDailyTimeBucket(hour) {
        if (hour >= 5 && hour <= 11) return "morning";
        if (hour >= 12 && hour <= 16) return "afternoon";
        if (hour >= 17 && hour <= 21) return "evening";
        return "late_night";
      }

      function defaultDailyCheckinPlan(profile, localHour) {
        const bucket = localDailyTimeBucket(localHour);
        const intro = "Specialists prepared this check-in for your goals and current time of day.";
        const steps = [...orderedCoreStepsByGoal(profile.goalFocus), DAILY_OPTIONAL_SIGNAL_STEP, DAILY_NOTES_STEP];
        return {
          goalFocus: profile.goalFocus || "general",
          timeBucket: bucket,
          intro,
          steps
        };
      }

      async function loadDailyCheckinPlan(profile) {
        const now = new Date();
        const fallback = defaultDailyCheckinPlan(profile, now.getHours());
        try {
          const res = await fetch("/coach/daily-checkin-plan", {
            method: "POST",
            headers: authHeaders(),
            body: JSON.stringify({
              local_hour: now.getHours(),
              timezone_offset_minutes: now.getTimezoneOffset(),
              generate_with_ai: true
            })
          });
          if (!res.ok) return fallback;
          const body = await res.json();
          const rows = Array.isArray(body.questions) ? body.questions : [];
          if (!rows.length) return fallback;
          const steps = rows
            .filter((x) => x && x.key && x.type && x.question)
            .map((x) => ({
              key: String(x.key),
              label: String(x.label || x.key),
              specialist: String(x.specialist || "Coach"),
              question: String(x.question),
              type: String(x.type),
              min: (x.min == null ? undefined : Number(x.min)),
              max: (x.max == null ? undefined : Number(x.max)),
            }));
          if (!steps.length) return fallback;
          return {
            goalFocus: String(body.goal_focus || fallback.goalFocus),
            timeBucket: String(body.time_bucket || fallback.timeBucket),
            intro: String(body.intro || fallback.intro),
            steps,
          };
        } catch (_) {
          return fallback;
        }
      }

      async function loadDailyCheckinProfile() {
        try {
          const res = await fetch("/intake/baseline", { headers: { "Authorization": "Bearer " + token } });
          if (!res.ok) return { goalFocus: "general", primaryGoal: "", topGoals: [] };
          const body = await res.json();
          const primaryGoal = String(body.primary_goal || "");
          const topGoals = Array.isArray(body.top_goals) ? body.top_goals : [];
          return {
            goalFocus: detectGoalFocus(primaryGoal, topGoals),
            primaryGoal,
            topGoals
          };
        } catch (_) {
          return { goalFocus: "general", primaryGoal: "", topGoals: [] };
        }
      }

      async function loadDailyLogForDate(logDate) {
        try {
          const res = await fetch("/daily-log?from=" + encodeURIComponent(logDate) + "&to=" + encodeURIComponent(logDate), {
            headers: { "Authorization": "Bearer " + token }
          });
          if (!res.ok) return null;
          const body = await res.json();
          const items = Array.isArray(body.items) ? body.items : [];
          return items.length ? items[0] : null;
        } catch (_) {
          return null;
        }
      }

      async function loadMetricSignalsForDate(logDate) {
        try {
          // Use local-day boundaries converted to ISO UTC to avoid missing same-day local logs.
          const startLocal = new Date(String(logDate) + "T00:00:00");
          const endLocal = new Date(String(logDate) + "T23:59:59");
          const startIso = startLocal.toISOString();
          const endIso = endLocal.toISOString();
          const metricTypes = ["weight_kg", "bp_systolic", "bp_diastolic", "resting_hr_bpm"];
          const rows = [];
          for (const mt of metricTypes) {
            const url = "/metrics?metric_type=" + encodeURIComponent(mt)
              + "&from=" + encodeURIComponent(startIso)
              + "&to=" + encodeURIComponent(endIso);
            const res = await fetch(url, { headers: { "Authorization": "Bearer " + token } });
            if (!res.ok) continue;
            const body = await res.json().catch(() => ({}));
            if (Array.isArray(body.items)) rows.push(...body.items);
          }
          const hasType = (t) => rows.some((x) => String(x.metric_type || "").toLowerCase() === String(t).toLowerCase());
          return {
            weigh_in_done: hasType("weight_kg"),
            bp_checked: hasType("bp_systolic") || hasType("bp_diastolic"),
            hr_checked: hasType("resting_hr_bpm"),
          };
        } catch (_) {
          return { weigh_in_done: false, bp_checked: false, hr_checked: false };
        }
      }

      function hasValue(v) {
        if (v === null || v === undefined) return false;
        if (typeof v === "string") return v.trim().length > 0;
        return true;
      }

      function hydrateDailyPayloadFromExistingLog(existingLog) {
        if (!existingLog) return { payload: {}, extras: {}, answers: {}, answeredKeys: [] };
        const checkinBlob = (existingLog && typeof existingLog.checkin_payload_json === "object" && existingLog.checkin_payload_json)
          ? existingLog.checkin_payload_json
          : {};
        const parsedPayload = (checkinBlob && typeof checkinBlob.payload === "object") ? checkinBlob.payload : {};
        const parsedExtras = (checkinBlob && typeof checkinBlob.extras === "object") ? checkinBlob.extras : {};
        const parsedAnswers = (checkinBlob && typeof checkinBlob.answers === "object") ? checkinBlob.answers : {};
        const answeredKeys = Object.keys(parsedAnswers || {});
        const payload = {
          ...parsedPayload,
        };
        if (hasValue(existingLog.sleep_hours)) payload.sleep_hours = Number(existingLog.sleep_hours);
        if (hasValue(existingLog.energy)) payload.energy = Number(existingLog.energy);
        if (hasValue(existingLog.mood)) payload.mood = Number(existingLog.mood);
        if (hasValue(existingLog.stress)) payload.stress = Number(existingLog.stress);
        if (hasValue(existingLog.training_done)) payload.training_done = !!existingLog.training_done;
        if (hasValue(existingLog.nutrition_on_plan)) payload.nutrition_on_plan = !!existingLog.nutrition_on_plan;
        if (hasValue(existingLog.notes)) payload.notes = String(existingLog.notes);
        return {
          payload,
          extras: parsedExtras,
          answers: parsedAnswers,
          answeredKeys
        };
      }

      function filterPendingDailyCheckinSteps(steps, payload, hasExistingLog, evidence, answeredKeys) {
        const answered = new Set(Array.isArray(answeredKeys) ? answeredKeys.map((x) => String(x)) : []);
        let pending = Array.isArray(steps) ? steps.slice() : [];
        // Intake-like behavior: when today's check-in already exists, only ask unanswered fields.
        pending = pending.filter((step) => {
          if (!step || !step.key) return false;
          if (answered.has(String(step.key))) return false;
          if (DAILY_PAYLOAD_KEYS.has(step.key)) {
            return !hasValue(payload[step.key]);
          }
          if (step.key === "weight_kg" || step.key === "weigh_in_done") return !Boolean((evidence || {}).weigh_in_done);
          if (step.key === "bp" || step.key === "bp_checked") return !Boolean((evidence || {}).bp_checked);
          if (step.key === "resting_hr_bpm" || step.key === "hr_checked") return !Boolean((evidence || {}).hr_checked);
          // If a daily log already exists for today, skip optional signal loops by default.
          if (hasExistingLog && (step.key === "tracked_signals" || step.key === "notes")) {
            return false;
          }
          return true;
        });
        return pending;
      }

      function isCancelDailyCheckinInput(value) {
        const t = String(value || "").trim().toLowerCase();
        return t === "cancel" || t === "/cancel" || t === "stop";
      }

      function cancelDailyCheckin(reason) {
        if (!dailyCheckin.active) return;
        dailyCheckin.active = false;
        dailyCheckin.index = 0;
        dailyCheckin.payload = {};
        dailyCheckin.metricPayloads = [];
        dailyCheckin.extras = {};
        dailyCheckin.answers = {};
        dailyCheckin.steps = [];
        dailyCheckin.intro = "";
        dailyCheckin.latestSummaryMarkdown = "";
        el("chat-daily-cancel").style.display = "none";
        el("chat-question").value = "";
        const out = el("chat-answer");
        out.style.display = "block";
        out.innerHTML = "<h3>Check-In Canceled</h3><p>You can restart check-in anytime from this chat.</p>";
        setNotice("chat-notice", reason || "Check-in canceled.", "warn");
      }

      function renderDailyCheckinPrompt(extraMessage) {
        const out = el("chat-answer");
        out.style.display = "block";
        const step = currentDailyStep();
        const bucket = String(dailyCheckin.timeBucket || "").replace("_", " ");
        const hint = "Specialists adapt this check-in to your goals, current time of day, and tracked signals.";
        if (!step) {
          out.innerHTML = "<h3>Check-In Coach</h3><p>Preparing your adaptive check-in...</p>";
          return;
        }
        const specialist = step.specialist ? (String(step.specialist) + " asks:") : "Coach asks:";
        let onTrackHelp = "";
        const goal = String((dailyCheckin.profile || {}).goalFocus || "general");
        if (step.key === "nutrition_on_plan") {
          onTrackHelp = "This question confirms meal logging so coaching can tailor guidance to your actual intake.";
        } else if (step.key === "training_done") {
          onTrackHelp = "On-track training means you completed the planned session or your minimum movement target for today.";
        }
        out.innerHTML = "<h3>Check-In Coach</h3>"
          + (dailyCheckin.latestSummaryMarkdown
            ? ("<div style=\"margin:.5rem 0 .7rem;\">" + renderSimpleMarkdown(dailyCheckin.latestSummaryMarkdown) + "</div>")
            : "")
          + "<p><strong>Step " + (dailyCheckin.index + 1) + " of " + dailyCheckin.steps.length + ":</strong> " + escapeHtml(step.label) + "</p>"
          + "<p><strong>" + escapeHtml(specialist) + "</strong> " + escapeHtml(step.question) + "</p>"
          + (onTrackHelp ? "<p><em>" + escapeHtml(onTrackHelp) + "</em></p>" : "")
          + "<p><em>" + escapeHtml(hint) + " (" + escapeHtml(bucket) + "). Type 'cancel' to stop this check-in at any time.</em></p>"
          + (extraMessage ? "<p>" + escapeHtml(extraMessage) + "</p>" : "");
      }

      async function buildDailyFoodLogSummary(entryText) {
        const label = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
        const res = await fetch("/coach/daily-checkin/food-log-summary", {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify({
            entry_text: String(entryText || "").trim(),
            log_date: dailyCheckin.logDate,
            local_time_label: label
          })
        });
        if (!res.ok) return "";
        const body = await res.json().catch(() => ({}));
        return String(body.markdown || "").trim();
      }

      async function buildDailyStepSummary(step, rawAnswer, parsedValue) {
        const res = await fetch("/coach/daily-checkin/step-summary", {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify({
            key: String(step.key || ""),
            label: String(step.label || step.key || "Check-In"),
            specialist: String(step.specialist || "Coach"),
            raw_answer: String(rawAnswer || ""),
            parsed_value: parsedValue,
            log_date: dailyCheckin.logDate,
            time_bucket: String(dailyCheckin.timeBucket || ""),
            current_payload: dailyCheckin.payload || {},
            current_extras: dailyCheckin.extras || {}
          })
        });
        if (!res.ok) return "";
        const body = await res.json().catch(() => ({}));
        return String(body.markdown || "").trim();
      }

      function parseDailyCheckinValue(step, rawText) {
        const text = String(rawText || "").trim();
        if (!text) throw new Error("Please enter an answer.");
        if (step.type === "float" || step.type === "int") {
          const num = Number(text);
          if (!Number.isFinite(num)) throw new Error("Please enter a number.");
          if (num < step.min || num > step.max) {
            throw new Error("Value out of range for " + step.label + ".");
          }
          return step.type === "int" ? Math.round(num) : num;
        }
        if (step.type === "bool") {
          const normalized = text.toLowerCase();
          if (["y", "yes", "true", "1"].includes(normalized)) return true;
          if (["n", "no", "false", "0"].includes(normalized)) return false;
          throw new Error("Please answer yes or no.");
        }
        if (step.type === "weight") {
          const lower = text.toLowerCase();
          const num = Number((lower.match(/-?\d+(\.\d+)?/) || [])[0]);
          if (!Number.isFinite(num)) throw new Error("Please enter a valid weight.");
          const kg = (lower.includes("lb") || lower.includes("lbs") || lower.includes("pound")) ? (num * 0.45359237) : num;
          if (kg < 30 || kg > 350) throw new Error("Weight appears out of range.");
          return Math.round(kg * 100) / 100;
        }
        if (step.type === "bp") {
          const m = text.match(/(\d{2,3})\s*\/\s*(\d{2,3})/);
          if (!m) throw new Error("Please enter blood pressure like 120/80.");
          const s = Number(m[1]);
          const d = Number(m[2]);
          if (s < 70 || s > 240 || d < 40 || d > 150) throw new Error("Blood pressure appears out of range.");
          return { systolic: s, diastolic: d };
        }
        if (step.type === "signals") {
          const normalized = text.toLowerCase();
          if (normalized.includes("none")) return [];
          const selected = [];
          if (normalized.includes("weight")) selected.push("weight");
          if (normalized.includes("blood pressure") || normalized.includes("bp")) selected.push("bp");
          if (normalized.includes("bed") || normalized.includes("wake") || normalized.includes("sleep time")) selected.push("sleep_timing");
          if (normalized.includes("last meal") || normalized.includes("ate") || normalized.includes("meal time")) selected.push("last_meal");
          return selected;
        }
        if (step.type === "text") {
          if (step.key === "nutrition_log_choice") {
            const normalized = text.toLowerCase();
            if (["now", "log now", "yes", "y"].includes(normalized)) return "now";
            if (["later", "log later", "no", "n"].includes(normalized)) return "later";
            throw new Error("Please answer 'now' or 'later'.");
          }
          if (text.toLowerCase() === "skip") return null;
          return text.slice(0, 1200);
        }
        return text;
      }

      async function parseDailyCheckinBoolWithUtility(step, rawText) {
        const res = await fetch("/coach/daily-checkin/parse-answer", {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify({
            key: String(step.key || ""),
            question: String(step.question || ""),
            answer_text: String(rawText || ""),
            value_type: "bool",
            goal_focus: String((dailyCheckin.profile || {}).goalFocus || "general"),
            time_bucket: String(dailyCheckin.timeBucket || "unknown")
          })
        });
        if (!res.ok) throw new Error("Could not parse this check-in answer.");
        return await res.json();
      }

      async function startDailyCheckin() {
        if (dailyCheckin.active) {
          setNotice("chat-notice", "A check-in is already active. Answer, complete, or cancel it first.", "warn");
          return;
        }
        setBusy("checkin", true, "Check In (Working...)");
        const out = el("chat-answer");
        out.style.display = "block";
        out.innerHTML = "<h3>Check-In Coach</h3><p>Working in the background to build your specialist check-in...</p>"
          + "<p><em>This can take a few seconds while specialists generate questions from your goals and latest data.</em></p>";
        setNotice("chat-notice", "Building your adaptive check-in in the background...", "");
        try {
          const profile = await loadDailyCheckinProfile();
          const plan = await loadDailyCheckinPlan(profile);
          const logDate = new Date().toISOString().slice(0, 10);
          const existingLog = await loadDailyLogForDate(logDate);
          const evidence = await loadMetricSignalsForDate(logDate);
          const hydrated = hydrateDailyPayloadFromExistingLog(existingLog);
          const hydratedPayload = hydrated.payload || {};
          const pendingSteps = filterPendingDailyCheckinSteps(
            Array.isArray(plan.steps) ? plan.steps : [],
            hydratedPayload,
            !!existingLog,
            evidence,
            hydrated.answeredKeys || []
          );
          if (!pendingSteps.length) {
            dailyCheckin.active = false;
            dailyCheckin.index = 0;
            dailyCheckin.logDate = logDate;
            dailyCheckin.payload = hydratedPayload;
            dailyCheckin.metricPayloads = [];
            dailyCheckin.extras = hydrated.extras || {};
            dailyCheckin.answers = hydrated.answers || {};
            dailyCheckin.evidence = evidence;
            dailyCheckin.profile = profile;
            dailyCheckin.timeBucket = plan.timeBucket || "morning";
          dailyCheckin.intro = plan.intro || "";
          dailyCheckin.latestSummaryMarkdown = "";
          dailyCheckin.steps = [];
            el("chat-daily-cancel").style.display = "none";
            out.innerHTML = "<h3>Check-In Coach</h3><p>Today's check-in is already complete.</p>"
              + "<p><em>No pending questions right now. If needed, ask a direct update in chat (for example: \"update today's weight to 264.8 lb\").</em></p>";
            setNotice("chat-notice", "No pending check-in items for today.", "ok");
            return;
          }
          dailyCheckin.active = true;
          dailyCheckin.index = 0;
          dailyCheckin.logDate = logDate;
          dailyCheckin.payload = hydratedPayload;
          dailyCheckin.metricPayloads = [];
          dailyCheckin.extras = hydrated.extras || {};
          dailyCheckin.answers = hydrated.answers || {};
          dailyCheckin.evidence = evidence;
          dailyCheckin.profile = profile;
          dailyCheckin.timeBucket = plan.timeBucket || "morning";
          dailyCheckin.intro = plan.intro || "";
          dailyCheckin.latestSummaryMarkdown = "";
          dailyCheckin.steps = pendingSteps;
          el("chat-question").value = "";
          el("chat-question").focus();
          el("chat-daily-cancel").style.display = "inline-block";
          const starter = profile.primaryGoal
            ? ("Check-in started for your goal: " + profile.primaryGoal + ".")
            : "Check-in started.";
          let resumeNote = "";
          if (existingLog) {
            const completed = [];
            const pending = [];
            const labelByKey = Object.fromEntries((Array.isArray(plan.steps) ? plan.steps : []).map((s) => [s.key, s.label || s.key]));
            Object.keys(labelByKey).forEach((k) => {
              if (DAILY_PAYLOAD_KEYS.has(k)) {
                (hasValue(hydratedPayload[k]) ? completed : pending).push(String(labelByKey[k]));
              }
            });
            if (evidence.weigh_in_done) completed.push(String(labelByKey.weigh_in_done || "Weigh-In Done"));
            if (evidence.bp_checked) completed.push(String(labelByKey.bp_checked || "BP Checked"));
            if (evidence.hr_checked) completed.push(String(labelByKey.hr_checked || "HR Checked"));
            if (completed.length || pending.length) {
              resumeNote = " Resuming from today's check-in."
                + (completed.length ? (" Completed: " + completed.join(", ") + ".") : "")
                + (pending.length ? (" Pending: " + pending.join(", ") + ".") : "");
            } else {
              resumeNote = " Resuming from today's existing check-in; asking only pending items.";
            }
          }
          renderDailyCheckinPrompt("Answer in the chat box and press Send.");
          setNotice("chat-notice", starter + resumeNote + (dailyCheckin.intro ? (" " + dailyCheckin.intro) : ""), "ok");
        } finally {
          setBusy("checkin", false);
        }
      }

      async function submitDailyCheckin() {
        const payloadWithDynamic = {
          ...dailyCheckin.payload,
          checkin_payload_json: {
            payload: dailyCheckin.payload || {},
            extras: dailyCheckin.extras || {},
            answers: dailyCheckin.answers || {},
            evidence: dailyCheckin.evidence || {},
            time_bucket: dailyCheckin.timeBucket || "",
            updated_at_local: new Date().toISOString(),
          },
        };
        const res = await fetch("/daily-log/" + dailyCheckin.logDate, {
          method: "PUT",
          headers: authHeaders(),
          body: JSON.stringify(payloadWithDynamic),
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("chat-notice", body.detail || "Could not save check-in.", "error");
          return;
        }
        for (const metric of dailyCheckin.metricPayloads) {
          await fetch("/metrics", {
            method: "POST",
            headers: authHeaders(),
            body: JSON.stringify(metric)
          });
        }
        dailyCheckin.active = false;
        el("chat-daily-cancel").style.display = "none";
        const out = el("chat-answer");
        out.style.display = "block";
        out.innerHTML = "<h3>Check-In Saved</h3>"
          + "<p>Your check-in for " + dailyCheckin.logDate + " is saved.</p>"
          + "<p><em>Now ask any coaching question, and I will use this new daily signal.</em></p>";
        setNotice("chat-notice", "Check-in complete.", "ok");
      }

      async function handleDailyCheckinTurn(userInput) {
        if (isCancelDailyCheckinInput(userInput)) {
          cancelDailyCheckin("Check-in canceled. You can restart anytime.");
          return;
        }
        dailyCheckin.latestSummaryMarkdown = "";
        const step = currentDailyStep();
        if (!step) return;
        let parsed;
        let parseMeta = null;
        let loggedNutritionFromReply = false;
        try {
          parsed = parseDailyCheckinValue(step, userInput);
        } catch (err) {
          if (step.type === "bool") {
            try {
              parseMeta = await parseDailyCheckinBoolWithUtility(step, userInput);
              if (parseMeta && (parseMeta.parsed_bool === true || parseMeta.parsed_bool === false)) {
                parsed = parseMeta.parsed_bool;
              } else {
                throw new Error("Please answer clearly, and include details if you want them logged.");
              }
            } catch (parseErr) {
              setNotice("chat-notice", parseErr.message || err.message || "Invalid answer.", "error");
              renderDailyCheckinPrompt("Please try that step again.");
              return;
            }
          } else {
            setNotice("chat-notice", err.message || "Invalid answer.", "error");
            renderDailyCheckinPrompt("Please try that step again.");
            return;
          }
        }
        if (step.type === "bool" && parseMeta && parseMeta.captured_text) {
          dailyCheckin.extras[step.key + "_details"] = String(parseMeta.captured_text).slice(0, 600);
        }
        dailyCheckin.answers[step.key] = {
          specialist: String(step.specialist || "Coach"),
          question: String(step.question || ""),
          raw_answer: String(userInput || ""),
          parsed_value: parsed,
          captured_text: (parseMeta && parseMeta.captured_text) ? String(parseMeta.captured_text).slice(0, 600) : null,
          at_local: new Date().toISOString(),
        };
        if (step.key === "tracked_signals") {
          const chosen = Array.isArray(parsed) ? parsed : [];
          const optionalSteps = chosen
            .map((key) => DAILY_OPTIONAL_STEPS[key])
            .filter(Boolean);
          const notesIndex = dailyCheckin.steps.findIndex((s) => s.key === "notes");
          const insertionIndex = notesIndex >= 0 ? notesIndex : dailyCheckin.steps.length;
          dailyCheckin.steps.splice(insertionIndex, 0, ...optionalSteps);
        } else if (step.key === "weight_kg") {
          dailyCheckin.metricPayloads.push({
            metric_type: "weight_kg",
            value: parsed
          });
          dailyCheckin.extras.weight_kg = parsed;
        } else if (step.key === "bp") {
          dailyCheckin.metricPayloads.push({ metric_type: "bp_systolic", value: parsed.systolic });
          dailyCheckin.metricPayloads.push({ metric_type: "bp_diastolic", value: parsed.diastolic });
          dailyCheckin.extras.bp = parsed.systolic + "/" + parsed.diastolic;
        } else if (step.key === "resting_hr_bpm") {
          dailyCheckin.metricPayloads.push({ metric_type: "resting_hr_bpm", value: Number(parsed) });
          dailyCheckin.extras.resting_hr_bpm = Number(parsed);
        } else if (step.key === "sleep_timing") {
          dailyCheckin.extras.sleep_timing = parsed;
        } else if (step.key === "last_meal") {
          dailyCheckin.extras.last_meal = parsed;
        } else if (step.key === "nutrition_log_choice") {
          if (parsed === "now") {
            const exists = dailyCheckin.steps.some((s, idx) => idx > dailyCheckin.index && s.key === "nutrition_food_details");
            if (!exists) {
              dailyCheckin.steps.splice(dailyCheckin.index + 1, 0, DAILY_NUTRITION_LOG_DETAILS_STEP);
            }
          } else {
            dailyCheckin.extras.nutrition_log_later = "yes";
          }
        } else if (step.key === "nutrition_food_details") {
          dailyCheckin.extras.nutrition_food_details = parsed;
          // User chose to log now and provided details, so mark this as logged.
          dailyCheckin.payload.nutrition_on_plan = true;
          const rich = await buildDailyFoodLogSummary(String(parsed));
          if (rich) {
            dailyCheckin.latestSummaryMarkdown = rich;
          }
        } else {
          if (DAILY_PAYLOAD_KEYS.has(step.key)) {
            dailyCheckin.payload[step.key] = parsed;
          } else {
            dailyCheckin.extras[step.key] = parsed;
          }
        }
        if (step.key === "nutrition_on_plan" && parseMeta && parseMeta.captured_text) {
          dailyCheckin.extras.nutrition_food_details = String(parseMeta.captured_text).slice(0, 600);
          const rich = await buildDailyFoodLogSummary(String(parseMeta.captured_text));
          if (rich) {
            dailyCheckin.latestSummaryMarkdown = rich;
          }
          if (parsed === false) {
            // User replied "no" but still provided intake details; capture it as logged now.
            dailyCheckin.payload.nutrition_on_plan = true;
            loggedNutritionFromReply = true;
            dailyCheckin.extras.nutrition_logged_via_reply = "yes";
          }
        }
        if (step.key === "nutrition_on_plan" && parsed === false && !loggedNutritionFromReply) {
          const exists = dailyCheckin.steps.some((s, idx) => idx > dailyCheckin.index && s.key === "nutrition_log_choice");
          if (!exists) {
            dailyCheckin.steps.splice(dailyCheckin.index + 1, 0, DAILY_NUTRITION_LOG_CHOICE_STEP);
          }
        }
        if (!dailyCheckin.latestSummaryMarkdown) {
          const stepSummary = await buildDailyStepSummary(step, userInput, parsed);
          if (stepSummary) {
            dailyCheckin.latestSummaryMarkdown = stepSummary;
          }
        }
        dailyCheckin.index += 1;
        el("chat-question").value = "";
        if (dailyCheckin.index >= dailyCheckin.steps.length) {
          const extraBits = [];
          if (dailyCheckin.extras.weight_kg != null) extraBits.push("weight: " + dailyCheckin.extras.weight_kg + " kg");
          if (dailyCheckin.extras.bp) extraBits.push("bp: " + dailyCheckin.extras.bp);
          if (dailyCheckin.extras.sleep_timing) extraBits.push("sleep timing: " + dailyCheckin.extras.sleep_timing);
          if (dailyCheckin.extras.last_meal) extraBits.push("last meal: " + dailyCheckin.extras.last_meal);
          Object.keys(dailyCheckin.extras).forEach((k) => {
            if (["weight_kg", "bp", "sleep_timing", "last_meal"].includes(k)) return;
            const v = dailyCheckin.extras[k];
            if (v == null || v === "") return;
            extraBits.push(k.replace(/_/g, " ") + ": " + String(v));
          });
          if (extraBits.length) {
            const currentNotes = dailyCheckin.payload.notes ? String(dailyCheckin.payload.notes) + " | " : "";
            dailyCheckin.payload.notes = (currentNotes + extraBits.join("; ")).slice(0, 1200);
          }
          await submitDailyCheckin();
          return;
        }
        renderDailyCheckinPrompt();
        setNotice("chat-notice", "Captured. Next check-in question loaded.", "");
      }

      async function loadSession() {
        const res = await fetch("/auth/session", { headers: { "Authorization": "Bearer " + token } });
        if (!res.ok) {
          sessionStorage.removeItem("access_token");
          window.location.href = "/onboarding";
          return;
        }
        const body = await res.json();
        el("welcome").textContent = "Signed in as " + body.email;
      }

      function modelLabel(entry) {
        if (!entry.cost_known) return entry.model + " (cost n/a)";
        return entry.model + " ($" + Number(entry.input_cost_per_1m_usd).toFixed(2) + "/$" + Number(entry.output_cost_per_1m_usd).toFixed(2) + " per 1M)";
      }

      function renderModels(selectId, options, selected) {
        const node = el(selectId);
        node.innerHTML = '<option value="">Select model</option>';
        options.forEach((entry) => {
          const opt = document.createElement("option");
          opt.value = entry.model;
          opt.textContent = modelLabel(entry);
          node.appendChild(opt);
        });
        if (selected) node.value = selected;
      }

      async function loadModelOptions() {
        const provider = el("provider").value;
        const apiKey = el("api-key").value.trim();
        if (!provider || !apiKey) return;
        setNotice("ai-notice", "Validating key and loading models...", "");
        const res = await fetch("/auth/model-options", {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify({ ai_provider: provider, ai_api_key: apiKey })
        });
        if (!res.ok) {
          setNotice("ai-notice", "Could not validate key/models.", "error");
          return;
        }
        const body = await res.json();
        if (body.source !== "provider_api") {
          setNotice("ai-notice", "Provider key validation failed.", "error");
          return;
        }
        const opts = Array.isArray(body.model_options) ? body.model_options : [];
        renderModels("deep-model", opts, body.default_deep_thinker_model);
        renderModels("reason-model", opts, body.default_reasoning_model);
        renderModels("utility-model", opts, body.default_utility_model);
        setNotice("ai-notice", "Model catalog loaded.", "ok");
      }

      async function loadAiConfig() {
        const res = await fetch("/auth/ai-config", { headers: { "Authorization": "Bearer " + token } });
        if (!res.ok) {
          el("api-key").placeholder = "Required for first-time setup";
          el("api-key-mask").textContent = "";
          setNotice("ai-notice", "AI config not set yet.", "warn");
          return;
        }
        const body = await res.json();
        el("provider").value = body.ai_provider || "";
        renderModels("deep-model", [], body.ai_deep_thinker_model);
        renderModels("reason-model", [], body.ai_reasoning_model);
        renderModels("utility-model", [], body.ai_utility_model);
        el("api-key").value = "";
        el("api-key").placeholder = "Leave blank to keep existing key";
        el("api-key-mask").textContent = body.api_key_masked
          ? ("Saved key: " + body.api_key_masked)
          : "";
        setNotice("ai-notice", "Loaded current AI config. Enter a new API key only if you want to replace it.", "warn");
      }

      async function saveAiConfig() {
        const payload = {
          ai_provider: el("provider").value,
          ai_deep_thinker_model: el("deep-model").value,
          ai_reasoning_model: el("reason-model").value,
          ai_utility_model: el("utility-model").value,
          ai_api_key: el("api-key").value.trim()
        };
        if (!payload.ai_provider || !payload.ai_deep_thinker_model || !payload.ai_reasoning_model || !payload.ai_utility_model) {
          setNotice("ai-notice", "Provider and all three model slots are required.", "error");
          return;
        }
        const res = await fetch("/auth/ai-config", {
          method: "PUT",
          headers: authHeaders(),
          body: JSON.stringify(payload)
        });
        if (!res.ok) {
          setNotice("ai-notice", "Could not save AI settings.", "error");
          return;
        }
        const body = await res.json().catch(() => ({}));
        el("api-key").value = "";
        if (body.api_key_masked) {
          el("api-key-mask").textContent = "Saved key: " + body.api_key_masked;
        }
        setNotice("ai-notice", "AI settings updated.", "ok");
      }

      async function loadIntakeStatus() {
        const res = await fetch("/intake/status", { headers: { "Authorization": "Bearer " + token } });
        if (!res.ok) {
          setNotice("intake-status", "Could not load intake status.", "error");
          return;
        }
        const body = await res.json();
        intakePrimaryGoal = String(body.primary_goal || "");
        if (body.baseline_completed) {
          el("intake-badge").textContent = "completed";
          el("intake-badge").className = "status ok";
          el("intake-alert-dot").classList.remove("show");
          setNotice("intake-status", "Intake completed. You can update it anytime from this menu.", "ok");
        } else {
          el("intake-badge").textContent = "pending";
          el("intake-badge").className = "status warn";
          el("intake-alert-dot").classList.add("show");
          setNotice("intake-status", "Intake not completed yet. You can skip for now and run later from this menu.", "warn");
        }
      }

      function renderCoachState(payload) {
        intakeState.sessionId = payload.session_id;
        intakeState.readyToComplete = !!payload.ready_to_complete;
        const question = (payload.coach_message || "").trim();
        if (question) addIntakeChatMessage("coach", question);
        el("intake-complete").style.display = intakeState.readyToComplete ? "inline-block" : "none";
      }

      async function startIntakeConversation() {
        const topGoalsRaw = el("intake-top-goals").value.trim();
        const goals = topGoalsRaw
          ? topGoalsRaw.split(",").map((g) => g.trim()).filter((g) => g).slice(0, 3)
          : [];
        setNotice("intake-notice", "Starting intake coach...", "");
        setBusy("intake", true, "Starting...");
        try {
          const res = await fetch("/intake/conversation/start", {
            method: "POST",
            headers: authHeaders(),
            body: JSON.stringify({ top_goals: goals.length ? goals : null })
          });
          if (!res.ok) {
            const body = await res.json().catch(() => ({}));
            setNotice("intake-notice", body.detail || "Could not start intake coach.", "error");
            return;
          }
          el("intake-chat-log").innerHTML = "";
          intakeChat.length = 0;
          renderCoachState(await res.json());
          setNotice("intake-notice", "Coach started. Answer one or more requested items, then send.", "ok");
        } finally {
          setBusy("intake", false);
        }
      }

      async function sendIntakeAnswer() {
        const answer = el("intake-answer").value.trim();
        if (!intakeState.sessionId) {
          setNotice("intake-notice", "Start intake coach first.", "warn");
          return;
        }
        if (!answer) {
          setNotice("intake-notice", "Enter an answer first.", "error");
          return;
        }
        addIntakeChatMessage("user", answer);
        setNotice("intake-notice", "Sending answer...", "");
        setBusy("intake", true, "Sending...");
        try {
          const res = await fetch("/intake/conversation/answer", {
            method: "POST",
            headers: authHeaders(),
            body: JSON.stringify({ session_id: intakeState.sessionId, answer })
          });
          if (!res.ok) {
            const body = await res.json().catch(() => ({}));
            setNotice("intake-notice", body.detail || "Could not submit answer.", "error");
            return;
          }
          el("intake-answer").value = "";
          renderCoachState(await res.json());
          setNotice(
            "intake-notice",
            intakeState.readyToComplete
              ? "Ready to finalize intake."
              : "Answer recorded. Next intake batch loaded.",
            "ok"
          );
        } finally {
          setBusy("intake", false);
        }
      }

      async function finalizeIntakeConversation() {
        if (!intakeState.sessionId) {
          setNotice("intake-notice", "Start intake coach first.", "warn");
          return;
        }
        setNotice("intake-notice", "Finalizing intake...", "");
        setBusy("intake", true, "Finalizing...");
        try {
          const res = await fetch("/intake/conversation/complete", {
            method: "POST",
            headers: authHeaders(),
            body: JSON.stringify({ session_id: intakeState.sessionId })
          });
          if (!res.ok) {
            const body = await res.json().catch(() => ({}));
            setNotice("intake-notice", body.detail || "Could not finalize intake.", "error");
            return;
          }
          intakeState.readyToComplete = false;
          el("intake-complete").style.display = "none";
          setNotice("intake-notice", "Intake complete. Redirecting to default chat.", "ok");
          await loadIntakeStatus();
          showView("chat");
        } finally {
          setBusy("intake", false);
        }
      }

      async function sendChat() {
        const question = el("chat-question").value.trim();
        if (dailyCheckin.active) {
          if (selectedChatImage) {
            setNotice("chat-notice", "Finish or cancel the current check-in before uploading an image.", "warn");
            return;
          }
          if (!question) {
            setNotice("chat-notice", "Enter your check-in answer, or type 'cancel' to stop.", "error");
            return;
          }
          setBusy("chat", true, "Working...");
          try {
            await handleDailyCheckinTurn(question);
          } finally {
            setBusy("chat", false);
          }
          return;
        }
        const hasImage = !!selectedChatImage;
        if (hasImage) {
          await sendImageChat(question);
          return;
        }
        if (!question) {
          setNotice("chat-notice", "Enter a question first.", "error");
          return;
        }
        const resolved = resolveChatMode(question);
        const webSearchEnabled = isWebSearchEnabled();
        const plan = buildAgentProgressPlan(question, resolved);
        const stageMessages = (webSearchEnabled
          ? ["Researching current web evidence..."]
          : []).concat(plan.map((p) => p.label + ": working..."));
        const done = [];
        let stageIdx = 0;
        setBusy("chat", true, "Working...");
        setNotice("chat-notice", stageMessages[stageIdx], "");
        renderAgentStatus(plan, plan[stageIdx] ? plan[stageIdx].id : null, done);
        const noticeTimer = setInterval(() => {
          if (plan[stageIdx]) done.push(plan[stageIdx].id);
          stageIdx = (stageIdx + 1) % stageMessages.length;
          setNotice("chat-notice", stageMessages[stageIdx], "");
          renderAgentStatus(plan, plan[stageIdx] ? plan[stageIdx].id : null, done);
        }, 1300);
        try {
          const res = await fetch("/coach/question", {
            method: "POST",
            headers: authHeaders(),
            body: JSON.stringify({
              question,
              mode: resolved.mode,
              deep_think: resolved.deepThink,
              thread_id: chatState.currentThreadId,
              web_search: webSearchEnabled,
            })
          });
          if (!res.ok) {
            let detail = "";
            try {
              const errBody = await res.json();
              if (errBody && typeof errBody === "object") {
                if (typeof errBody.detail === "string" && errBody.detail.trim()) {
                  detail = errBody.detail.trim();
                } else if (Array.isArray(errBody.detail) && errBody.detail.length) {
                  detail = String(errBody.detail[0]?.msg || errBody.detail[0] || "").trim();
                }
              }
            } catch (_) {
              detail = "";
            }
            if (res.status === 401) {
              setNotice("chat-notice", "Chat request failed: session expired. Please sign in again.", "error");
            } else {
              setNotice(
                "chat-notice",
                detail ? ("Chat request failed: " + detail) : ("Chat request failed (" + res.status + ")."),
                "error"
              );
            }
            return;
          }
          const body = await res.json();
          el("chat-question").value = "";
          await renderChatCoachResponse(body, resolved, question, plan);
        } catch (err) {
          const message = (err && err.message) ? err.message : "Network error";
          setNotice("chat-notice", "Chat request failed: " + message, "error");
        } finally {
          clearInterval(noticeTimer);
          setBusy("chat", false);
        }
      }

      async function sendImageChat(questionText) {
        if (dailyCheckin.active) {
          setNotice("chat-notice", "Finish current check-in before uploading an image.", "warn");
          return;
        }
        if (!selectedChatImage) {
          setNotice("chat-notice", "Select an image first.", "error");
          return;
        }
        const resolved = resolveChatMode(questionText || "image analysis");
        const webSearchEnabled = isWebSearchEnabled();
        const form = new FormData();
        form.append("image", selectedChatImage);
        form.append("question", String(questionText || ""));
        form.append("mode", resolved.mode);
        form.append("deep_think", String(!!resolved.deepThink));
        form.append("web_search", String(webSearchEnabled));
        if (chatState.currentThreadId) {
          form.append("thread_id", String(chatState.currentThreadId));
        }
        setBusy("chat", true, "Analyzing...");
        setNotice("chat-notice", "Analyzing image with coach...", "");
        try {
          const res = await fetch("/coach/image", {
            method: "POST",
            headers: { "Authorization": "Bearer " + token },
            body: form,
          });
          if (!res.ok) {
            const body = await res.json().catch(() => ({}));
            setNotice("chat-notice", body.detail || "Image request failed.", "error");
            return;
          }
          const body = await res.json();
          selectedChatImage = null;
          el("chat-image-file").value = "";
          el("chat-question").value = "";
          await renderChatCoachResponse(body, resolved, "[Image] " + (questionText || "Analyze upload"), []);
        } finally {
          setBusy("chat", false);
        }
      }

      async function renderChatCoachResponse(body, resolved, userPrompt, plan) {
        const out = el("chat-answer");
        out.style.display = "none";
        out.innerHTML = "";
        if (userPrompt) {
          chatState.messages.push({ role: "user", content: userPrompt });
        }
        chatState.messages.push({ role: "assistant", content: body.answer || "" });
        renderChatLog();
        chatState.currentThreadId = body.thread_id || chatState.currentThreadId;
        await loadChatThreads();
        const trace = Array.isArray(body.agent_trace) ? body.agent_trace : [];
        if (trace.length) {
          const ids = trace.map((x) => String(x.agent_id || "")).filter(Boolean);
          const labelsById = {};
          trace.forEach((x) => {
            const id = String(x.agent_id || "");
            if (!id) return;
            labelsById[id] = String(x.agent_title || id);
          });
          const mergedPlan = [];
          const pushUnique = (id, label) => {
            if (!id) return;
            if (mergedPlan.some((node) => node.id === id)) return;
            mergedPlan.push({ id, label });
          };
          (Array.isArray(plan) ? plan : []).forEach((node) => {
            pushUnique(String(node.id || ""), String(node.label || node.id || ""));
          });
          ids.forEach((id) => {
            pushUnique(id, labelsById[id] || id);
          });
          renderAgentStatus(mergedPlan, null, ids);
        } else if (Array.isArray(plan) && plan.length) {
          const ids = plan.map((x) => x.id);
          renderAgentStatus(plan, null, ids);
        }
        const flags = Array.isArray(body.safety_flags) ? body.safety_flags : [];
        const llmFailure = flags.some((f) => String(f).startsWith("llm_"));
        if (llmFailure) {
          if (flags.includes("llm_rate_limited")) {
            setNotice("chat-notice", "AI provider rate limit/quota reached. Returned practical fallback guidance.", "warn");
          } else if (flags.includes("llm_unavailable") || flags.includes("llm_provider_error")) {
            setNotice("chat-notice", "AI service timed out or is temporarily unavailable. Returned practical fallback guidance.", "warn");
          } else if (flags.includes("llm_auth_error") || flags.includes("llm_model_not_found")) {
            setNotice("chat-notice", "AI configuration issue detected. Check Settings and model selection.", "error");
          } else {
            setNotice("chat-notice", "AI provider/model error. Check Settings (provider, key, and model selections).", "error");
          }
        } else {
          setNotice("chat-notice", "Response ready (" + resolved.label + " mode).", "ok");
        }
      }

      async function sendVoiceTranscript(transcript) {
        const text = String(transcript || "").trim();
        if (!text) {
          setNotice("chat-notice", "No transcript captured. Try again.", "error");
          return;
        }
        const resolved = resolveChatMode(text);
        const webSearchEnabled = isWebSearchEnabled();
        setBusy("chat", true, "Sending...");
        setNotice("chat-notice", "Sending voice transcript...", "");
        try {
          const res = await fetch("/coach/voice", {
            method: "POST",
            headers: authHeaders(),
            body: JSON.stringify({
              transcript: text,
              mode: resolved.mode,
              deep_think: resolved.deepThink,
              thread_id: chatState.currentThreadId,
              web_search: webSearchEnabled,
            })
          });
          if (!res.ok) {
            setNotice("chat-notice", "Voice request failed.", "error");
            return;
          }
          const body = await res.json();
          el("chat-question").value = "";
          await renderChatCoachResponse(body, resolved, text, []);
        } finally {
          setBusy("chat", false);
        }
      }

      async function fetchOverallSummarySafe() {
        const res = await fetch("/summary/overall", { headers: { "Authorization": "Bearer " + token } });
        if (!res.ok) return null;
        return await res.json();
      }

      async function fetchBaselineSafe() {
        const res = await fetch("/intake/baseline", { headers: { "Authorization": "Bearer " + token } });
        if (!res.ok) return null;
        return await res.json();
      }

      async function fetchProactiveCard(cardType) {
        const res = await fetch("/coach/proactive-card", {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify({ card_type: cardType }),
        });
        if (!res.ok) return null;
        return await res.json().catch(() => null);
      }

      function doneMark(done) {
        return done ? "[x]" : "[ ]";
      }

      function pushChatAssistantMarkdown(userPrompt, assistantMarkdown) {
        if (userPrompt) chatState.messages.push({ role: "user", content: userPrompt });
        chatState.messages.push({ role: "assistant", content: assistantMarkdown || "" });
        renderChatLog();
      }

      async function showDailySummaryCard() {
        if (dailyCheckin.active) {
          setNotice("chat-notice", "Finish or cancel current check-in first.", "warn");
          return;
        }
        setBusy("chat", true, "Working...");
        setNotice("chat-notice", "Building daily summary...", "");
        try {
          const card = await fetchProactiveCard("daily_summary");
          if (!card || !card.markdown) {
            setNotice("chat-notice", "Could not load daily summary.", "error");
            return;
          }
          pushChatAssistantMarkdown("Daily Summary", String(card.markdown || ""));
          setNotice("chat-notice", "Daily summary ready.", "ok");
        } finally {
          setBusy("chat", false);
        }
      }

      async function showDailyPlanCard() {
        if (dailyCheckin.active) {
          setNotice("chat-notice", "Finish or cancel current check-in first.", "warn");
          return;
        }
        setBusy("chat", true, "Working...");
        setNotice("chat-notice", "Building daily plan...", "");
        try {
          const card = await fetchProactiveCard("daily_plan");
          if (!card || !card.markdown) {
            setNotice("chat-notice", "Could not load daily plan.", "error");
            return;
          }
          pushChatAssistantMarkdown("Daily Plan", String(card.markdown || ""));
          setNotice("chat-notice", "Daily plan ready.", "ok");
        } finally {
          setBusy("chat", false);
        }
      }

      async function showWhatNextCard() {
        if (dailyCheckin.active) {
          setNotice("chat-notice", "Finish or cancel current check-in first.", "warn");
          return;
        }
        setBusy("chat", true, "Working...");
        setNotice("chat-notice", "Building next-step guidance...", "");
        try {
          const card = await fetchProactiveCard("what_next");
          if (!card || !card.markdown) {
            setNotice("chat-notice", "Could not load next-step guidance.", "error");
            return;
          }
          pushChatAssistantMarkdown("What Next", String(card.markdown || ""));
          setNotice("chat-notice", "What-next guidance ready.", "ok");
        } finally {
          setBusy("chat", false);
        }
      }

      function startVoiceInput() {
        if (dailyCheckin.active) {
          setNotice("chat-notice", "Finish current check-in before using voice.", "warn");
          return;
        }
        if (voiceListening) return;
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          setNotice("chat-notice", "Voice input is not supported in this browser.", "warn");
          return;
        }
        speechRecognition = new SpeechRecognition();
        speechRecognition.lang = "en-US";
        speechRecognition.interimResults = false;
        speechRecognition.maxAlternatives = 1;
        voiceListening = true;
        el("chat-voice").classList.add("listening");
        setNotice("chat-notice", "Listening... speak your question.", "");
        speechRecognition.onresult = async (event) => {
          const transcript = (((event || {}).results || [])[0] || [])[0]?.transcript || "";
          el("chat-question").value = transcript;
          await sendVoiceTranscript(transcript);
        };
        speechRecognition.onerror = () => {
          setNotice("chat-notice", "Voice input failed. Try again.", "error");
        };
        speechRecognition.onend = () => {
          voiceListening = false;
          el("chat-voice").classList.remove("listening");
        };
        speechRecognition.start();
      }

      function openImagePicker() {
        el("chat-image-file").click();
      }

      function onImageSelected(event) {
        const file = (((event || {}).target || {}).files || [])[0] || null;
        selectedChatImage = file;
        if (!file) {
          setNotice("chat-notice", "No image selected.", "warn");
          return;
        }
        setNotice("chat-notice", "Image selected: " + file.name + ". Ready to send.", "ok");
      }

      async function changePassword() {
        const payload = {
          current_password: el("current-password").value,
          new_password: el("new-password").value
        };
        if (!payload.current_password || !payload.new_password) {
          setNotice("password-notice", "Current and new password are required.", "error");
          return;
        }
        const res = await fetch("/auth/change-password", {
          method: "PUT",
          headers: authHeaders(),
          body: JSON.stringify(payload)
        });
        if (res.status === 204) {
          el("current-password").value = "";
          el("new-password").value = "";
          setNotice("password-notice", "Password updated.", "ok");
          return;
        }
        const body = await res.json().catch(() => ({}));
        setNotice("password-notice", body.detail || "Password update failed.", "error");
      }

      async function loadNotificationSettings() {
        const res = await fetch("/auth/notification-settings", {
          headers: { "Authorization": "Bearer " + token }
        });
        if (!res.ok) {
          setNotice("notify-notice", "Could not load reminder settings.", "error");
          return;
        }
        const body = await res.json();
        reminderState.enabled = !!body.enabled;
        reminderState.intervalMinutes = Number(body.interval_minutes || 120);
        reminderState.title = String(body.reminder_title || reminderState.title);
        reminderState.body = String(body.reminder_body || reminderState.body);
        el("notify-enabled").value = reminderState.enabled ? "on" : "off";
        el("notify-interval").value = String(reminderState.intervalMinutes);
        scheduleReminderTimer();
      }

      async function saveNotificationSettings() {
        const enabled = el("notify-enabled").value === "on";
        const intervalRaw = Number(el("notify-interval").value || "120");
        const interval = Number.isFinite(intervalRaw) ? Math.round(intervalRaw) : 120;
        if (interval < 15 || interval > 1440) {
          setNotice("notify-notice", "Interval must be between 15 and 1440 minutes.", "error");
          return;
        }
        const res = await fetch("/auth/notification-settings", {
          method: "PUT",
          headers: authHeaders(),
          body: JSON.stringify({
            enabled,
            interval_minutes: interval
          })
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("notify-notice", body.detail || "Could not save reminder settings.", "error");
          return;
        }
        const body = await res.json();
        reminderState.enabled = !!body.enabled;
        reminderState.intervalMinutes = Number(body.interval_minutes || 120);
        reminderState.title = String(body.reminder_title || reminderState.title);
        reminderState.body = String(body.reminder_body || reminderState.body);
        scheduleReminderTimer();
        setNotice("notify-notice", "Reminder settings saved.", "ok");
      }

      async function requestNotificationPermission() {
        if (!notificationSupported()) {
          setNotice("notify-notice", "This browser does not support notifications.", "warn");
          return;
        }
        const permission = await Notification.requestPermission();
        if (permission === "granted") {
          scheduleReminderTimer();
          setNotice("notify-notice", "Browser notification permission granted.", "ok");
        } else {
          setNotice("notify-notice", "Notification permission was not granted.", "warn");
        }
      }

      function sendTestNotification() {
        if (!notificationSupported()) {
          setNotice("notify-notice", "This browser does not support notifications.", "warn");
          return;
        }
        if (Notification.permission !== "granted") {
          setNotice("notify-notice", "Grant browser notification permission first.", "warn");
          return;
        }
        showReminderNotification();
        setNotice("notify-notice", "Test reminder sent.", "ok");
      }

      async function resetModelUsage() {
        const ok = window.confirm("Reset model usage stats for this account only?");
        if (!ok) return;
        setNotice("reset-notice", "Resetting model stats...", "");
        const res = await fetch("/auth/model-usage", {
          method: "DELETE",
          headers: { "Authorization": "Bearer " + token }
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("reset-notice", body.detail || "Could not reset model stats.", "error");
          return;
        }
        const body = await res.json().catch(() => ({}));
        setNotice("reset-notice", "Model stats reset. Rows removed: " + (body.deleted_rows ?? 0) + ".", "ok");
        await loadUsage();
      }

      async function resetDailyData() {
        const ok = window.confirm(
          "Clear daily logs, metrics, scores, and conversation summaries for this account only? Intake baseline will be kept."
        );
        if (!ok) return;
        setNotice("reset-notice", "Clearing daily data...", "");
        const res = await fetch("/auth/daily-data", {
          method: "DELETE",
          headers: { "Authorization": "Bearer " + token }
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("reset-notice", body.detail || "Could not clear daily data.", "error");
          return;
        }
        const body = await res.json().catch(() => ({}));
        setNotice("reset-notice", "Daily data cleared. Rows removed: " + (body.deleted_rows ?? 0) + ".", "ok");
        await loadSummary();
        await loadUsage();
      }

      async function resetUserData() {
        const ok = window.confirm(
          "Reinitialize user data (baseline, intake sessions, metrics, scores, daily logs, and chat summaries)? This cannot be undone."
        );
        if (!ok) return;
        setNotice("reset-notice", "Reinitializing user data...", "");
        const res = await fetch("/auth/data", {
          method: "DELETE",
          headers: { "Authorization": "Bearer " + token }
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("reset-notice", body.detail || "Could not reinitialize user data.", "error");
          return;
        }
        const body = await res.json().catch(() => ({}));
        setNotice("reset-notice", "User data reinitialized. Rows removed: " + (body.deleted_rows ?? 0) + ".", "ok");
        await loadIntakeStatus();
        startNewChat();
        await loadChatThreads();
        showView("chat");
      }

      async function submitFeedback() {
        const payload = {
          category: el("feedback-category").value,
          title: el("feedback-title").value.trim(),
          details: el("feedback-details").value.trim(),
          page: el("feedback-page").value.trim() || null,
        };
        if (!payload.title || !payload.details) {
          setNotice("feedback-notice", "Title and details are required.", "error");
          return;
        }
        setNotice("feedback-notice", "Saving entry...", "");
        const res = await fetch("/feedback/entries", {
          method: "POST",
          headers: authHeaders(),
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("feedback-notice", body.detail || "Could not save entry.", "error");
          return;
        }
        const body = await res.json().catch(() => ({}));
        setNotice("feedback-notice", "Saved entry #" + (body.id ?? "?") + ".", "ok");
        el("feedback-title").value = "";
        el("feedback-details").value = "";
        el("feedback-page").value = "";
      }

      async function exportFeedbackCsv() {
        setNotice("feedback-notice", "Preparing CSV...", "");
        const res = await fetch("/feedback/entries/export", {
          headers: { "Authorization": "Bearer " + token },
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("feedback-notice", body.detail || "Could not export CSV.", "error");
          return;
        }
        const blob = await res.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "feedback_entries.csv";
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(url);
        setNotice("feedback-notice", "CSV downloaded.", "ok");
      }

      async function clearAllFeedback() {
        const ok = window.confirm("Clear all feedback entries for all users?");
        if (!ok) return;
        setNotice("feedback-notice", "Clearing shared entries...", "");
        const res = await fetch("/feedback/entries", {
          method: "DELETE",
          headers: { "Authorization": "Bearer " + token },
        });
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          setNotice("feedback-notice", body.detail || "Could not clear entries.", "error");
          return;
        }
        const body = await res.json().catch(() => ({}));
        setNotice("feedback-notice", "Cleared entries: " + (body.deleted_rows ?? 0) + ".", "ok");
      }

      async function loadUsage() {
        const res = await fetch("/auth/model-usage", { headers: { "Authorization": "Bearer " + token } });
        if (!res.ok) {
          el("usage-hint").textContent = "Could not load usage.";
          return;
        }
        const body = await res.json();
        const tbody = el("usage-table").querySelector("tbody");
        tbody.innerHTML = "";
        const items = body.items || [];
        if (!items.length) {
          el("usage-hint").textContent = "No model usage yet. Ask a chat question to generate usage.";
          return;
        }
        items.forEach((item) => {
          const tr = document.createElement("tr");
          let roughCost = "n/a";
          if (typeof item.rough_cost_usd === "number" && Number.isFinite(item.rough_cost_usd)) {
            roughCost = "$" + Number(item.rough_cost_usd).toFixed(4);
          }
          tr.innerHTML = "<td>" + item.provider + "</td><td>" + item.model + "</td><td>" + item.request_count + "</td><td>" + item.prompt_tokens + "</td><td>" + item.completion_tokens + "</td><td>" + item.total_tokens + "</td><td>" + roughCost + "</td>";
          tbody.appendChild(tr);
        });
        el("usage-hint").textContent = "Rows are aggregated by provider/model for your account. Rough cost is estimated from known per-1M token pricing.";
      }

      function renderWindowSummary(window) {
        if (!window || !window.entries) return "<p>No entries in this window yet.</p>";
        return "<ul>"
          + "<li><strong>Entries:</strong> " + window.entries + "</li>"
          + "<li><strong>Avg Sleep:</strong> " + (window.avg_sleep_hours ?? "n/a") + "</li>"
          + "<li><strong>Avg Energy:</strong> " + (window.avg_energy ?? "n/a") + "</li>"
          + "<li><strong>Avg Mood:</strong> " + (window.avg_mood ?? "n/a") + "</li>"
          + "<li><strong>Avg Stress:</strong> " + (window.avg_stress ?? "n/a") + "</li>"
          + "<li><strong>Training Adherence:</strong> " + (window.training_adherence_pct ?? "n/a") + "%</li>"
          + "<li><strong>Nutrition Adherence:</strong> " + (window.nutrition_adherence_pct ?? "n/a") + "%</li>"
          + "</ul>";
      }

      async function loadOverallSummary() {
        setNotice("summary-notice", "Loading summary...", "");
        const res = await fetch("/summary/overall", { headers: { "Authorization": "Bearer " + token } });
        if (!res.ok) {
          setNotice("summary-notice", "Could not load summary.", "error");
          return;
        }
        const body = await res.json();
        const today = body.today || {};
        const categoryScores = body.category_scores || {};
        const wellnessReport = Array.isArray(body.wellness_report) ? body.wellness_report : [];
        const weeklyInsights = Array.isArray(body.weekly_personalized_insights) ? body.weekly_personalized_insights : [];
        const journey = body.personalized_journey || {};
        const journeySignals = Array.isArray(journey.pattern_signals) ? journey.pattern_signals : [];
        const journeyMeasures = Array.isArray(journey.prevention_measures) ? journey.prevention_measures : [];
        el("summary-health").innerHTML = "<h3>Health Score</h3><p><strong>" + (body.health_score ?? "n/a") + "/100</strong></p>"
          + "<p>Reflects Body Composition, Nutrition, Movement, Sleep, and Stress.</p>"
          + "<h4>Category Scores</h4><ul>"
          + Object.keys(categoryScores).map((k) => "<li><strong>" + escapeHtml(k) + ":</strong> " + categoryScores[k] + "/100</li>").join("")
          + "</ul>";
        el("summary-today").innerHTML = "<h3>Today</h3><ul>"
          + "<li><strong>Date:</strong> " + (today.log_date || "n/a") + "</li>"
          + "<li><strong>Sleep:</strong> " + (today.sleep_hours ?? "n/a") + "</li>"
          + "<li><strong>Energy:</strong> " + (today.energy ?? "n/a") + "</li>"
          + "<li><strong>Mood:</strong> " + (today.mood ?? "n/a") + "</li>"
          + "<li><strong>Stress:</strong> " + (today.stress ?? "n/a") + "</li>"
          + "<li><strong>Training:</strong> " + (today.training_done ? "yes" : "no") + "</li>"
          + "<li><strong>Nutrition:</strong> " + (today.nutrition_on_plan ? "yes" : "no") + "</li>"
          + "</ul>";
        el("summary-trends").innerHTML = "<h3>7-Day Trend</h3>" + renderWindowSummary(body.trend_7d)
          + "<h3>30-Day Trend</h3>" + renderWindowSummary(body.trend_30d);
        el("summary-insights").innerHTML = "<h3>Wellness Report</h3><ul>"
          + wellnessReport.map((row) => "<li><strong>" + escapeHtml(row.domain || "") + ":</strong> " + escapeHtml(String(row.status || "")) + " (" + (row.score ?? "n/a") + "/100)</li>").join("")
          + "</ul><h3>Weekly Personalized Insights</h3><ul>"
          + weeklyInsights.map((v) => "<li>" + escapeHtml(v) + "</li>").join("")
          + "</ul><h3>Personalized Journey</h3><p>" + escapeHtml(String(journey.narrative || "")) + "</p><h4>Detected Patterns</h4><ul>"
          + journeySignals.map((s) => "<li><strong>" + escapeHtml(String(s.pattern || "")) + ":</strong> " + escapeHtml(String(s.evidence || "")) + " -> " + escapeHtml(String(s.prevention_focus || "")) + "</li>").join("")
          + "</ul><h4>Prevention Measures</h4><ul>"
          + journeyMeasures.map((m) => "<li>" + escapeHtml(String(m || "")) + "</li>").join("")
          + "</ul><h3>Top Wins</h3><ul>"
          + (body.top_wins || []).map((v) => "<li>" + escapeHtml(v) + "</li>").join("")
          + "</ul><h3>Top Risks</h3><ul>"
          + (body.top_risks || []).map((v) => "<li>" + escapeHtml(v) + "</li>").join("")
          + "</ul><h3>Next Best Action</h3><p>" + escapeHtml(body.next_best_action || "n/a") + "</p>";
        setNotice("summary-notice", "Summary updated.", "ok");
      }

      el("menu-chat").addEventListener("click", async () => { showView("chat"); await loadChatThreads(); renderChatLog(); });
      el("menu-summary").addEventListener("click", async () => { showView("summary"); await loadOverallSummary(); });
      el("menu-intake").addEventListener("click", () => showView("intake"));
      el("menu-settings").addEventListener("click", () => showView("settings"));
      el("menu-usage").addEventListener("click", async () => { showView("usage"); await loadUsage(); });
      el("menu-feedback").addEventListener("click", () => showView("feedback"));
      el("logout").addEventListener("click", () => { sessionStorage.removeItem("access_token"); window.location.href = "/onboarding"; });
      el("chat-send").addEventListener("click", sendChat);
      el("chat-daily-summary").addEventListener("click", async () => { await showDailySummaryCard(); });
      el("chat-daily-plan").addEventListener("click", async () => { await showDailyPlanCard(); });
      el("chat-what-next").addEventListener("click", async () => { await showWhatNextCard(); });
      el("chat-new-thread").addEventListener("click", startNewChat);
      el("chat-refresh-threads").addEventListener("click", loadChatThreads);
      el("chat-history-hide").addEventListener("click", toggleHistoryCollapsed);
      el("chat-history-show").addEventListener("click", toggleHistoryCollapsed);
      el("chat-voice").addEventListener("click", startVoiceInput);
      el("chat-image").addEventListener("click", openImagePicker);
      el("chat-image-file").addEventListener("change", onImageSelected);
      el("chat-clear").addEventListener("click", () => {
        el("chat-question").value = "";
        selectedChatImage = null;
        el("chat-image-file").value = "";
        setNotice("chat-notice", "", "");
      });
      el("chat-daily-start").addEventListener("click", async () => { await startDailyCheckin(); });
      el("chat-daily-cancel").addEventListener("click", () => { cancelDailyCheckin("Check-in canceled by user."); });
      el("chat-mode-button").addEventListener("click", (event) => {
        event.preventDefault();
        toggleModePanel();
      });
      document.querySelectorAll(".mode-option").forEach((node) => {
        node.addEventListener("click", () => applyModeSelection(node.getAttribute("data-mode") || "auto"));
      });
      document.addEventListener("click", (event) => {
        const wrap = document.querySelector(".mode-wrap");
        if (!wrap || wrap.contains(event.target)) return;
        closeModePanel();
      });
      el("intake-start").addEventListener("click", startIntakeConversation);
      el("intake-answer-send").addEventListener("click", sendIntakeAnswer);
      el("intake-complete").addEventListener("click", finalizeIntakeConversation);
      el("intake-refresh").addEventListener("click", loadIntakeStatus);
      el("intake-chat-expand").addEventListener("click", toggleIntakeChatExpanded);
      el("ai-load").addEventListener("click", loadAiConfig);
      el("provider").addEventListener("change", loadModelOptions);
      el("api-key").addEventListener("input", () => { if (el("api-key").value.trim().length > 7) loadModelOptions(); });
      el("ai-save").addEventListener("click", saveAiConfig);
      el("password-save").addEventListener("click", changePassword);
      el("notify-save").addEventListener("click", saveNotificationSettings);
      el("notify-permission").addEventListener("click", requestNotificationPermission);
      el("notify-test").addEventListener("click", sendTestNotification);
      el("reset-daily-data").addEventListener("click", resetDailyData);
      el("reset-user-data").addEventListener("click", resetUserData);
      el("reset-model-usage").addEventListener("click", resetModelUsage);
      el("usage-refresh").addEventListener("click", loadUsage);
      el("summary-refresh").addEventListener("click", loadOverallSummary);
      el("feedback-submit").addEventListener("click", submitFeedback);
      el("feedback-export").addEventListener("click", exportFeedbackCsv);
      el("feedback-clear-all").addEventListener("click", clearAllFeedback);
      el("feedback-clear-form").addEventListener("click", () => {
        el("feedback-title").value = "";
        el("feedback-details").value = "";
        el("feedback-page").value = "";
        setNotice("feedback-notice", "", "");
      });
      el("menu-toggle").addEventListener("click", toggleDrawer);
      el("menu-close").addEventListener("click", closeDrawer);
      el("menu-overlay").addEventListener("click", closeDrawer);

      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          closeModePanel();
          closeDrawer();
          return;
        }
        if (event.key !== "Enter") return;
        const target = event.target;
        if (target && target.tagName === "TEXTAREA") {
          if (event.shiftKey) return;
          event.preventDefault();
          if (el("view-chat").classList.contains("active")) sendChat();
          if (el("view-intake").classList.contains("active")) sendIntakeAnswer();
          return;
        }
        if (target && target.id === "chat-question") {
          if (event.shiftKey) return;
          event.preventDefault();
          sendChat();
        }
      });

      async function init() {
        applyModeSelection("auto");
        initHistoryCollapsedState();
        await loadSession();
        await loadIntakeStatus();
        await loadAiConfig();
        await loadNotificationSettings();
        await loadChatThreads();
        renderChatLog();
        if ((window.location.hash || "").toLowerCase() === "#intake") {
          showView("intake");
        }
      }
      init();
    </script>
  </body>
</html>




